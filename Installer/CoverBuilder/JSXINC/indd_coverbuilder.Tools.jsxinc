// Tools for InDesign
// Indesign helpers for CoverBuilder
// Bruno Herfst 2014 - 2016
// Version 1.4

(function() {
    //////////////
    // privates //
    //////////////

    //-----------------------------------------------------------------------------------
    // APPLICATION TOOLS
    //-----------------------------------------------------------------------------------

    function setRuler(doc, myNewUnits){

        // This function sets the rulers to the disired measure units
        // and returns the original setting that you can send back to
        // this function to reset the rulers.

        var myOldUnits = {xruler : doc.viewPreferences.horizontalMeasurementUnits, yruler: doc.viewPreferences.verticalMeasurementUnits, origin: doc.viewPreferences.rulerOrigin, zeroPoint: doc.zeroPoint };

        if (myNewUnits.hasOwnProperty('xruler') && myNewUnits.hasOwnProperty('yruler')){
            doc.viewPreferences.horizontalMeasurementUnits = myNewUnits.xruler;
            doc.viewPreferences.verticalMeasurementUnits   = myNewUnits.yruler;
        } else if( myNewUnits.hasOwnProperty('units')) {
            // Set both rulers to the same unit
            // We will cast everything to string so it can parse a wide variaty of input including the MeasurementUnits object
            var stringUnits = String(myNewUnits.units).toLowerCase();
            with(doc.viewPreferences){
                switch(stringUnits) {
                    case "0":
                    case "millimeters":
                    case "mm":
                    case "millimeter":
                    case "zmms":
                    case "2053991795":
                        horizontalMeasurementUnits = MeasurementUnits.MILLIMETERS;
                        verticalMeasurementUnits   = MeasurementUnits.MILLIMETERS;
                        break;
                    case "1":
                    case "inchesDecimal":
                    case "inch": // shorthand to decimal
                    case "zoll":
                    case "pouce":
                    case "zind":
                    case "2053729892":
                        horizontalMeasurementUnits = MeasurementUnits.INCHES_DECIMAL;
                        verticalMeasurementUnits   = MeasurementUnits.INCHES_DECIMAL;
                        break;
                    case "inches":
                    case "zinc":
                    case "2053729891":
                        horizontalMeasurementUnits = MeasurementUnits.INCHES;
                        verticalMeasurementUnits   = MeasurementUnits.INCHES;
                        break;
                    case "2":
                    case "points":
                    case "pt":
                    case "zpoi":
                    case "2054188905":
                        horizontalMeasurementUnits = MeasurementUnits.POINTS;
                        verticalMeasurementUnits   = MeasurementUnits.POINTS;
                        break;
                    case "american_points":
                    case "apt":
                    case "zapt":
                    case "1514238068":
                        horizontalMeasurementUnits = MeasurementUnits.AMERICAN_POINTS;
                        verticalMeasurementUnits   = MeasurementUnits.AMERICAN_POINTS;
                        break;
                    case "agates":
                    case "zagt":
                    case "2051106676":
                        horizontalMeasurementUnits = MeasurementUnits.AGATES;
                        verticalMeasurementUnits   = MeasurementUnits.AGATES;
                        break;
                    case "bai":
                    case "zbai":
                    case "2051170665":
                        horizontalMeasurementUnits = MeasurementUnits.BAI;
                        verticalMeasurementUnits   = MeasurementUnits.BAI;
                        break;
                    case "cm":
                    case "centimeter":
                    case "centimeters":
                    case "zcms":
                    case "2053336435":
                        horizontalMeasurementUnits = MeasurementUnits.CENTIMETERS;
                        verticalMeasurementUnits   = MeasurementUnits.CENTIMETERS;
                        break;
                    case "ciceros":
                    case "c":
                    case "zcic":
                    case "2053335395":
                        horizontalMeasurementUnits = MeasurementUnits.CICEROS;
                        verticalMeasurementUnits   = MeasurementUnits.CICEROS;
                        break;
                    case "custom":
                    case "cstm":
                    case "1131639917":
                        horizontalMeasurementUnits = MeasurementUnits.CUSTOM;
                        verticalMeasurementUnits   = MeasurementUnits.CUSTOM;
                        break;
                    case "ha":
                    case "zha":
                    case "1516790048":
                        horizontalMeasurementUnits = MeasurementUnits.HA;
                        verticalMeasurementUnits   = MeasurementUnits.HA;
                        break;
                    case "mils":
                    case "zmil":
                    case "2051893612":
                        horizontalMeasurementUnits = MeasurementUnits.MILS;
                        verticalMeasurementUnits   = MeasurementUnits.MILS;
                        break;
                    case "picas":
                    case "p":
                    case "zpic":
                    case "2054187363":
                        horizontalMeasurementUnits = MeasurementUnits.PICAS;
                        verticalMeasurementUnits   = MeasurementUnits.PICAS;
                        break;
                    case "pixels":
                    case "pixel":
                    case "px":
                    case "zpix":
                    case "2054187384":
                        horizontalMeasurementUnits = MeasurementUnits.PIXELS;
                        verticalMeasurementUnits   = MeasurementUnits.PIXELS;
                        break;
                    case "q":
                    case "zque":
                    case "2054255973":
                        horizontalMeasurementUnits = MeasurementUnits.Q;
                        verticalMeasurementUnits   = MeasurementUnits.Q;
                        break;
                    case "u":
                    case "zju":
                    case "2051691808":
                        horizontalMeasurementUnits = MeasurementUnits.U;
                        verticalMeasurementUnits   = MeasurementUnits.U;
                        break;
                    default:
                        alert("Function setRuler:\nCould not parse MeasurementUnits: " + typeof(myNewUnits) + " " + myNewUnits );
                        break;
                }
            }
        }

        if(myNewUnits.hasOwnProperty('origin')){
            doc.viewPreferences.rulerOrigin = myNewUnits.origin;
        } else { // Use page origin if not defined
            doc.viewPreferences.rulerOrigin = RulerOrigin.pageOrigin;
        }
        if(myNewUnits.hasOwnProperty('zeroPoint')) {
            doc.zeroPoint = myNewUnits.zeroPoint;
        } else { // Use zero point if not defined
            doc.zeroPoint = [0,0];
        }
        return myOldUnits;
    }

    function setRedraw(myOriginalPrefs){
        // This function is a rewite of forceRedraw by by Jon S. Winters
        // http://extendscript.blogspot.com.au/2009/09/force-redraw-adobe-indesign.html

        //-- Store and then clear the redraw preferences and original view setting.
        //-- The view setting will be changed to force the redraw to happen.
        var myOldRedrawPrefs = {enableRedraw : app.scriptPreferences.enableRedraw, viewDisplaySetting : app.activeWindow.viewDisplaySetting}

        if (typeof myOriginalPrefs != "undefined") { // Reset origial settings
            if( myOriginalPrefs.hasOwnProperty('enableRedraw') && myOriginalPrefs.hasOwnProperty('viewDisplaySetting') ){
                // reset original redraw preferences
                app.activeWindow.viewDisplaySetting = myOriginalPrefs.viewDisplaySetting;
                app.scriptPreferences.enableRedraw = myOriginalPrefs.enableRedraw;
                return myOldRedrawPrefs;
            }
        }

        app.scriptPreferences.enableRedraw = false;

        //-- If the view is anything but optimized, switch to optimized. It is FAST but you can't see anything
        if ( myOldRedrawPrefs.viewDisplaySetting != ViewDisplaySettings.OPTIMIZED ) {
            app.activeWindow.viewDisplaySetting = ViewDisplaySettings.OPTIMIZED ;
        } else { //-- Otherwise switch to Typical as it is the second fastest.
            app.activeWindow.viewDisplaySetting = ViewDisplaySettings.TYPICAL ;
        }

        return myOldRedrawPrefs;
    }

    //-----------------------------------------------------------------------------------
    // DOCUMENT TOOLS
    //-----------------------------------------------------------------------------------

    function getShorthandDocUnits (myApp, doc, vertical){
        // This function returns the shorthand for horizontal measure unit
        // unless if vertical is set to true
        var vertical = vertical || false;
        if(vertical){
            var inddUnits = parseInt(doc.viewPreferences.verticalMeasurementUnits);
        } else {
            var inddUnits = parseInt(doc.viewPreferences.horizontalMeasurementUnits);
        }
        return {inddUnits: inddUnits, txt: myApp.Tools.inddUnits2Shorthand(inddUnits)};
    }

    function getBookTitle(myApp, myDoc, dontSaveTitle){
        var dontSaveTitle = dontSaveTitle || false;
        // This function gets the title of the book
        // and shows a UI to ask for the title if title is unknown
        var booktitle = myDoc.metadataPreferences.documentTitle;

        if( booktitle == ""){
            var bookTitleUI = app.dialogs.add({name:String(myApp.Localise.Meta['WhatIsTheTitleOfThisBook']),canCancel:true});
            with(bookTitleUI){
                with(dialogColumns.add()){
                    var titleEditField = textEditboxes.add({editContents:"", minWidth:200});
                }
             }
             var myResult = bookTitleUI.show();
             if(myResult == true){
                 booktitle = titleEditField.editContents;
                 if(!dontSaveTitle){
                    myDoc.metadataPreferences.documentTitle = booktitle;
                 }
             }
             bookTitleUI.destroy();
        }

        return String(booktitle);
    }

    function getActiveCover(myApp, returnAnyDoc, returnNull){
        // Check if we want to return Active Document if it is not a cover
        var returnAnyDoc = returnAnyDoc || false;
        var returnNull   = returnNull   || false;

        //Make certain that user interaction (display of dialogs, etc.) is turned on.
        app.scriptPreferences.userInteractionLevel = UserInteractionLevels.interactWithAll;

        if (app.documents.length <= 0) {
            if(returnNull){
                return null;
            } else {
                alert(String(myApp.Localise.UIalert['Open_document_before_using_function']));
                exit();
            }
        }

        var doc = app.documents[0];

        if(returnAnyDoc || isBuildWithCoverBuilder(myApp, doc)){
            return doc;
        } else {
            if(returnNull){
                return null;
            } else {
                alert(String(myApp.Localise.UIalert['failed_to_retrieve_c_object']));
                exit();
            }
        }
    }

    function createActiveCover(myApp, C) {
        // Create cover
        var doc = myApp.Build.cover(myApp, C);
        app.activeDocument = doc;
        return doc;
    }

    function getOrCreateActiveCover(myApp, C, returnAnyDoc) {
        // Check if we want to return Active Document before creating a new one
        var returnAnyDoc = Boolean(returnAnyDoc == true);

        //Make certain that user interaction (display of dialogs, etc.) is turned on.
        app.scriptPreferences.userInteractionLevel = UserInteractionLevels.interactWithAll;

        if (app.documents.length <= 0) {
            return createActiveCover(myApp, C);
        }

        var doc = app.documents[0];

        if(returnAnyDoc || isBuildWithCoverBuilder(myApp, doc)){
            // Check if doc matches Cover object
            var checkC = myApp.Check.CagainstDoc(myApp, doc, C, false); // returnOBJ = { C : C, changed : false, message : {ok : true, text : "Check OK."} };

            if(checkC.message.ok){
                return doc;
            }

        }
        // We haven't returned an open document
        // So let's create a new cover
        return createActiveCover(myApp, C);
    }

    function getDocBleed(myApp, doc) {
        // Function assumes rulers to be set correctly
        return {top:            doc.documentPreferences.documentBleedTopOffset,
                insideOrLeft:   doc.documentPreferences.documentBleedInsideOrLeftOffset,
                outsideOrRight: doc.documentPreferences.documentBleedOutsideOrRightOffset,
                bottom:         doc.documentPreferences.documentBleedBottomOffset};
    }

    function setDocBleed(myApp, doc, CR) {
        // Make sure C is resolved
        if(!CR.resolved){
            CR = myApp.STools.resolveSizes(myApp, CR);
        }
        // Function assumes rulers to be set correctly
        doc.documentPreferences.documentBleedTopOffset = CR.bleed;
        doc.documentPreferences.documentBleedInsideOrLeftOffset = CR.bleed;
        doc.documentPreferences.documentBleedOutsideOrRightOffset = CR.bleed;
        doc.documentPreferences.documentBleedBottomOffset = CR.bleed;
        myApp.Tools.setSlugs(myApp, doc, CR.measureUnit);
        // Slugs have changed make sure we reset measurements
        myApp.Slugs.placeSizesInSlug(myApp, doc, CR);
    }

    function setMinSlugs(myApp, doc, measureUnit) {
        // Function assumes rulers to be set correctly
        var mySlug = myApp.NumCon.convert(myApp, 5, "mm", measureUnit );
        doc.documentPreferences.slugTopOffset             = mySlug + doc.documentPreferences.documentBleedTopOffset;
        doc.documentPreferences.slugRightOrOutsideOffset  = mySlug + doc.documentPreferences.documentBleedOutsideOrRightOffset;
        doc.documentPreferences.slugBottomOffset          = mySlug + doc.documentPreferences.documentBleedBottomOffset;
        doc.documentPreferences.slugInsideOrLeftOffset    = mySlug + doc.documentPreferences.documentBleedInsideOrLeftOffset;
    }

    function setSlugs(myApp, doc, measureUnit) {
        // Function assumes rulers to be set correctly
        var mySlug = myApp.NumCon.convert(myApp, myApp.Settings.Slugs.measure, myApp.Settings.Slugs.unit, measureUnit );
        doc.documentPreferences.slugTopOffset             = mySlug + doc.documentPreferences.documentBleedTopOffset;
        doc.documentPreferences.slugRightOrOutsideOffset  = mySlug + doc.documentPreferences.documentBleedOutsideOrRightOffset;
        doc.documentPreferences.slugBottomOffset          = mySlug + doc.documentPreferences.documentBleedBottomOffset;
        doc.documentPreferences.slugInsideOrLeftOffset    = mySlug + doc.documentPreferences.documentBleedInsideOrLeftOffset;
    }

    function saveJSONLabel(myApp, doc, labelName, myObject){
        // This function saves the given object as JSON string in give document under given label name
        doc.insertLabel(labelName, myApp.JSON.stringify(myObject) );
        // Return with label, this way you can check if it's all good!
        return myApp.JSON.parse(doc.extractLabel(labelName) );
    }

    function retrieveJSONLabel(myApp, doc, labelName){
        // This function returns an object that has been saved as JSON string to spread
        // Or null if the label has no content
        var myJSONstring = doc.extractLabel(labelName);
        if(myJSONstring != ""){
            //alert(myJSONstring);
            var myObject = myApp.JSON.parse(doc.extractLabel(labelName));
            //alert(CB.JSON.stringify(myObject.process));
            return myObject;
        }
        return null;
    }
    
    function clearOverflowMargins( myMargin, pageWidth, pageHeight ) {
        // This function assumes all measurements are in the same units
        if ( myMargin.top + myMargin.bottom >= pageHeight ) {
            myMargin.top    = 0;
            myMargin.bottom = 0;
        }
        if ( myMargin.left + myMargin.right >= pageWidth ) {
            myMargin.left  = 0;
            myMargin.right = 0;
        }
        return myMargin;
    }

    function createBlueprint(myApp, C) {
        // Make sure C is resolved so all measurements are in the same units
        
        // We need to validate C here so it is actually in a shape we can build
        // Working on it on a diffrent branch!
  
        if(!C.resolved){
            var C = myApp.STools.resolveSizes(myApp, C);
        }

        var bluePrint = new Array();

        var bindingHinge = 0;
        var cvr14Hinge   = 0;

        if( C.hasOwnProperty("hinge") ) {
          cvr14Hinge   = C.hinge | 0;
        }

        if(C.spine > 0) {
            // Add spine
            var margin = {  top:    C.margin.Spine.top,
                            bottom: C.margin.Spine.bottom,
                            left:   C.margin.Spine.inside_left,
                            right:  C.margin.Spine.outside_right,
                            units:  C.margin.Spine.units };
            
            margin = clearOverflowMargins( margin, C.spine, C.height );
            
            bluePrint.push({width:C.spine, height:C.height, type:"Spine", margin:margin });
        }

        if (C.binding > 0) {

            if(C.binding > C.hinge){
                bindingHinge = C.hinge;
                cvr14Hinge = 0;
            }
            // Add binding R
            var margin = {  top:    C.margin.QB.top,
                            bottom: C.margin.QB.bottom,
                            left:   C.margin.QB.inside_left,
                            right:  C.margin.QB.outside_right,
                            units:  C.margin.QB.units };

            if(bindingHinge > 0){
                margin.left += C.hinge;
            }
    
            margin = clearOverflowMargins( margin, C.binding, C.height );
            
            if ( margin.left == 0 && bindingHinge > 0 ) margin.left = C.hinge;
            
            bluePrint.push(    {width:C.binding, height:C.height, type:"Binding1", margin:margin, hinge:bindingHinge} );

            // Add binding L
            if(C.spine > 0) {
                var margin = {  top:    C.margin.QB.top,
                                bottom: C.margin.QB.bottom,
                                left:   C.margin.QB.outside_right,
                                right:  C.margin.QB.inside_left,
                                units:  C.margin.QB.units };

                if(bindingHinge > 0){
                    margin.right += C.hinge;
                }
                
                margin = clearOverflowMargins( margin, C.binding, C.height );

                if ( margin.right == 0 && bindingHinge > 0 ) margin.right = C.hinge;

                bluePrint.unshift( {width:C.binding, height:C.height, type:"Binding4", margin:margin, hinge:C.binding-bindingHinge} );
            }
        }

        // Add CVR1
        var margin = {  top:    C.margin.CVR14.top,
                        bottom: C.margin.CVR14.bottom,
                        left:   C.margin.CVR14.inside_left,
                        right:  C.margin.CVR14.outside_right,
                        units:  C.margin.CVR14.units };
    
        if(cvr14Hinge > 0){
            margin.left += C.hinge;
        }
        
        margin = clearOverflowMargins( margin, C.width, C.height );

        if ( margin.left == 0 && cvr14Hinge > 0 ) margin.left = C.hinge;

        bluePrint.push(    {width:C.width, height:C.height, type:"CVR1", margin:margin, hinge:cvr14Hinge} );

        // Add CVR4
        if(C.spine > 0) {
            var margin = {  top:    C.margin.CVR14.top,
                            bottom: C.margin.CVR14.bottom,
                            left:   C.margin.CVR14.outside_right,
                            right:  C.margin.CVR14.inside_left,
                            units:  C.margin.CVR14.units };
    
            if(cvr14Hinge > 0){
                margin.right += C.hinge;
            }
            
            margin = clearOverflowMargins( margin, C.width, C.height );
            
            if ( margin.right == 0 && cvr14Hinge > 0 ) margin.right = C.hinge;
    
            bluePrint.unshift( {width:C.width, height:C.height, type:"CVR4", margin:margin, hinge:C.width-cvr14Hinge} );
        }

        if(C.flap > 0) {
            // Flap Front
            var margin = {  top:    C.margin.Flaps.top,
                            bottom: C.margin.Flaps.bottom,
                            left:   C.margin.Flaps.inside_left,
                            right:  C.margin.Flaps.outside_right,
                            units:  C.margin.Flaps.units };

            margin.left += C.fold;
            
            margin = clearOverflowMargins( margin, C.flap, C.height );
            
            if ( margin.left == 0 ) margin.left = C.fold;
            
            bluePrint.push( {width:C.flap, height:C.height, type:"Flap1", margin:margin, fold:C.fold} );

            // Flap Back
            if(C.spine > 0) {
                var margin = {  top:    C.margin.Flaps.top,
                                bottom: C.margin.Flaps.bottom,
                                left:   C.margin.Flaps.outside_right,
                                right:  C.margin.Flaps.inside_left,
                                units:  C.margin.Flaps.units };

                margin.right += C.fold;
                
                margin = clearOverflowMargins( margin, C.flap, C.height );
                
                if ( margin.right == 0 ) margin.right = C.fold;

                bluePrint.unshift( {width:C.flap, height:C.height, type:"Flap4", margin:margin, fold:C.flap-C.fold} );
            }
        }
        return bluePrint;
    }

    function isBuildWithCoverBuilder(myApp, myDoc){
        if( myDoc.extractLabel('createdByCoverBuilder') == 'true' ) {
            return true;
        }
        // Older versions of CoverBuilder
        var mySpine = myDoc.metadataPreferences.getProperty("http://brunoherfst.com/","Settings[3]");
        if(mySpine == "") {
            return false;
        } else {
            return true;
        }
    }

    function isBuildWithOther(myApp, myDoc){
        var foundLabels = myDoc.pageItems.everyItem().label;
        for (var i = 0; i < foundLabels.length; i++) {
            if( foundLabels[i].substr(0,4) == 'MBJ-' ) {
                return "Make Book Jacket";
            }
        }
        return "unknown";
    }

    function guessMarginObj(myApp, myDoc, cUnit){
        // Clone standard margin Object
        try{
            var MarginObj = myApp.JSON.parse(myApp.JSON.stringify(myApp.STools.MarginObj));
        } catch (e) {
            alert("CoverBuilder Error:\n" + e.message +  " (Line " + e.line + " in file " + e.fileName + ")");
        }
        // !! This function expects the document rulers to be set in the right measure units
        for(var page in MarginObj){
            MarginObj[page].top           = myApp.NumCon.doRound( myDoc.pages.item(0).marginPreferences.top    , 3);
            MarginObj[page].outside_right = myApp.NumCon.doRound( myDoc.pages.item(0).marginPreferences.right  , 3);
            MarginObj[page].inside_left   = myApp.NumCon.doRound( myDoc.pages.item(0).marginPreferences.left   , 3);
            MarginObj[page].bottom        = myApp.NumCon.doRound( myDoc.pages.item(0).marginPreferences.bottom , 3);
            MarginObj[page].units         = parseInt(cUnit);
        }
        return MarginObj;
    }

    function sameRulers( myDoc ){
        // Checks if both rulers are set to the same measure
        // Return boolean
        if(myDoc.viewPreferences.horizontalMeasurementUnits != myDoc.viewPreferences.verticalMeasurementUnits) {
            alert("CoverBuilder sameRuler(): Expected both document rulers to be set to the same measurement units.");
            return false;
        }
        return true;
    }

    function getMaxSlug( myApp, myDoc ){
        //This function returns the maximum slug size in current measure unit
        if( myApp.Tools.sameRulers(myDoc) ) {
            return Math.max( myDoc.documentPreferences.slugBottomOffset,
                             myDoc.documentPreferences.slugInsideOrLeftOffset,
                             myDoc.documentPreferences.slugRightOrOutsideOffset,
                             myDoc.documentPreferences.slugTopOffset);
        }
        alert("CoverBuilder getMaxSlug(): Document rulers are not set to the same measure units.");
        return myDoc.documentPreferences.slugTopOffset;
    }

    function getMinSlug( myApp, myDoc ){
        //This function returns the minimum slug size in current measure unit
        if( myApp.Tools.sameRulers(myDoc) ) {
            return Math.min( myDoc.documentPreferences.slugBottomOffset,
                             myDoc.documentPreferences.slugInsideOrLeftOffset,
                             myDoc.documentPreferences.slugRightOrOutsideOffset,
                             myDoc.documentPreferences.slugTopOffset);
        }
        alert("CoverBuilder getMinSlug(): Document rulers are not set to the same measure units.");
        return myDoc.documentPreferences.slugTopOffset;
    }

    function getMaxBleed( myApp, myDoc ){
        //This function returns the maximum bleed size in current measure unit
        if( myApp.Tools.sameRulers(myDoc) ) {
            return Math.max( myDoc.documentPreferences.documentBleedTopOffset,
                             myDoc.documentPreferences.documentBleedBottomOffset,
                             myDoc.documentPreferences.documentBleedInsideOrLeftOffset,
                             myDoc.documentPreferences.documentBleedOutsideOrRightOffset);
        }
        return myDoc.documentPreferences.documentBleedTopOffset;
    }

    function guessCfromUnknown(myApp, myDoc, NewC){
        // This function assumes rulers are set to NewC.measureUnit!
        var docPrefs = myDoc.documentPreferences;

        NewC.width  = myApp.NumCon.doRound( docPrefs.pageWidth  ,3);
        NewC.height = myApp.NumCon.doRound( myApp.Tools.getSpreadSize(myApp, myDoc.spreads[0]).height ,3);
        NewC.ppi    = myApp.Settings.standardPPI;
        NewC.bleed  = myApp.NumCon.doRound( docPrefs.documentBleedTopOffset ,3);
        NewC.slugs  = myApp.Tools.getMinSlug(myApp, myDoc) - NewC.bleed;
        NewC.margin = guessMarginObj(myApp, myDoc, NewC.measureUnit);

        //Let's see if the document might be a cover
        //if(!docPrefs.facingPages){ This can still be a cover!

        if(myDoc.spreads[0].pages.length == 1) {
            var firstPage = myDoc.pages[0];
            var pageWidth = myApp.Tools.getSpreadSize(myApp, myDoc.spreads[0]).width;

            NewC.width = myApp.NumCon.doRound( pageWidth, 3);

            if( firstPage.marginPreferences.columnCount == 2 ){
                var assumeSpine  = firstPage.marginPreferences.columnGutter;
                var assumeWidth  = (pageWidth-assumeSpine)/2;
                NewC.width = myApp.NumCon.doRound( assumeWidth, 3);
                NewC.spine = myApp.NumCon.doRound( assumeSpine, 3);
            } else {
                // Maybe Extreme Margin Technique?
                var leftMargin  = firstPage.marginPreferences.left;
                var rightMargin = firstPage.marginPreferences.right;
                var assumeSpine = pageWidth - leftMargin - rightMargin;
                var assumeWidth = (leftMargin + rightMargin)/2;
                
                if ( Math.abs(leftMargin-rightMargin) < 1 /* Tolerance */ ) {
                    // Both margins are equal
                    // Check if spine is smaller then two thirds
                    if ( assumeSpine < pageWidth * 0.66 ) {
                        NewC.width = myApp.NumCon.doRound( assumeWidth, 3);
                        NewC.spine = myApp.NumCon.doRound( assumeSpine, 3);
                    }
                }
            }
        }

        if(myDoc.spreads[0].pages.length == 2) {
            // CoverBuilder does not support building covers without a spine
            // But we can still load what we have into the interface
            NewC.height = myApp.NumCon.doRound( myApp.Tools.getSpreadSize(myApp, myDoc.spreads[0]).height    ,3);
            NewC.width  = myApp.NumCon.doRound( myApp.Tools.getSpreadSize(myApp, myDoc.spreads[0]).width / 2 ,3);
        }

        else if(myDoc.spreads[0].pages.length == 3){
            // Middle page is spine
            var spinePage = makePageInfoObject(myApp, myDoc, myDoc.spreads[0].pages[1], NewC.measureUnit);
            var cvr1 = makePageInfoObject(myApp, myDoc, myDoc.spreads[0].pages[2], NewC.measureUnit);
            var cvr4 = makePageInfoObject(myApp, myDoc, myDoc.spreads[0].pages[0], NewC.measureUnit);
            var assumeWidth = Math.max( cvr1.w, cvr4.w );

            NewC.spine = spinePage.w;
            NewC.width = assumeWidth;
        }

        if(myDoc.spreads[0].pages.length == 4) {
            // CoverBuilder does not support building covers without a spine
            // But we can still load what we have into the interface
            var cvr1  = makePageInfoObject(myApp, myDoc, myDoc.spreads[0].pages[1], NewC.measureUnit);
            var cvr4  = makePageInfoObject(myApp, myDoc, myDoc.spreads[0].pages[2], NewC.measureUnit);
            var flap1 = makePageInfoObject(myApp, myDoc, myDoc.spreads[0].pages[0], NewC.measureUnit);
            var flap4 = makePageInfoObject(myApp, myDoc, myDoc.spreads[0].pages[3], NewC.measureUnit);
            var assumeWidth = Math.max( cvr1.w,  cvr4.w  );
            var assumeFlap  = Math.max( flap1.w, flap4.w );

            NewC.width = assumeWidth;
            NewC.flap  = assumeFlap;
        }

        else if(myDoc.spreads[0].pages.length == 5){
            // Middle page is spine
            var spinePage = makePageInfoObject(myApp, myDoc, myDoc.spreads[0].pages[2], NewC.measureUnit);
            var cvr1      = makePageInfoObject(myApp, myDoc, myDoc.spreads[0].pages[3], NewC.measureUnit);
            var cvr4      = makePageInfoObject(myApp, myDoc, myDoc.spreads[0].pages[1], NewC.measureUnit);
            var flap1     = makePageInfoObject(myApp, myDoc, myDoc.spreads[0].pages[4], NewC.measureUnit);
            var flap4     = makePageInfoObject(myApp, myDoc, myDoc.spreads[0].pages[0], NewC.measureUnit);

            var assumeSpine = spinePage.w;
            var assumeWidth = Math.max( cvr1.w,  cvr4.w  );
            var assumeFlap  = Math.max( flap1.w, flap4.w );

            NewC.spine = assumeSpine;
            NewC.width = assumeWidth;
            NewC.flap  = assumeFlap;
        }
        return NewC;
    }

    function guessCfromMBJ(myApp, myDoc, NewC){
        // this function adjusts NewC to reflect a build from Make Book Jacket
        // it only checks the first spread
        if(myDoc.spreads[0].pages.length != 1) {
            return myApp.Tools.guessCfromUnknown(myApp, myDoc, NewC);
        }

        NewC.ppi    = myApp.Settings.standardPPI;
        NewC.bleed  = myApp.Tools.getMaxBleed(myApp, myDoc);
        NewC.slugs  = myApp.Tools.getMaxSlug(myApp, myDoc) - NewC.bleed;
        NewC.margin = guessMarginObj(myApp, myDoc, NewC.measureUnit);

        var cpage    = myDoc.spreads[0].pages[0];
        var cpBounds = myApp.Tools.getBoundsInfo(cpage.bounds);
        //var completeCoverWidth  = pageBoundsInfo.width;
        //var completeCoverHeight = pageBoundsInfo.height;

        NewC.height = cpBounds.height;
        NewC.width  = cpBounds.width/2;

        if( cpage.marginPreferences.columnCount == 2 ){
            var assumeSpine  = cpage.marginPreferences.columnGutter;
            var assumeWidth  = (cpBounds.width-assumeSpine)/2;
            NewC.width = assumeWidth;
            NewC.spine = assumeSpine;
        }

        // - - - - - - - - - - - - - - - - - - - - - -
        // C H E C K   F R O M   C R O P   M A R K S
        // - - - - - - - - - - - - - - - - - - - - - - 
        // Check if there are flaps from crop marks
        var lFlapMarkers = myApp.Tools.getItemByLabel(cpage, ["MBJ-FoldMark-BackFlapLeftSafetyTop" , "MBJ-FoldMark-BackFlapLeftSafetyBottom"]);
        var rFlapMarkers = myApp.Tools.getItemByLabel(cpage, ["MBJ-FoldMark-FrontFlapRightSafetyTop" , "MBJ-FoldMark-FrontFlapRightSafetyBottom"]);

        var lFlap,  rFlap,  lFold,  rFold;
            lFlap = rFlap = lFold = rFold = 0;

        if( lFlapMarkers.length > 0) {
            var lFlapMarkerInfo = myApp.Tools.getBoundsInfo(lFlapMarkers[0].geometricBounds);
            var lFlap  = lFlapMarkerInfo.midCenter.x;
        }

        if( rFlapMarkers.length > 0) {
            var rFlapMarkerInfo = myApp.Tools.getBoundsInfo(rFlapMarkers[0].geometricBounds);
            var rFlap = cpBounds.width-rFlapMarkerInfo.midCenter.x;
        }

        // Note that CoverBuilder can't handle uneven flaps at the moment

        // This ensures document keeps the same width
        // Needs a user alert

        var flaps = lFlap + rFlap;
        
        if(flaps > 0) {
            NewC.flap = flaps/2;
            NewC.width -= NewC.flap;
        }

        // Check if there is a fold from crop marks
        var lFoldMarkers = myApp.Tools.getItemByLabel(cpage, ["MBJ-FoldMark-BackFlapRightSafetyTop" , "MBJ-FoldMark-BackFlapRightSafetyBottom"]);
        var rFoldMarkers = myApp.Tools.getItemByLabel(cpage, ["MBJ-FoldMark-FrontFlapLeftSafetyTop" , "MBJ-FoldMark-FrontFlapLeftSafetyBottom"]);

        if( lFoldMarkers.length > 0) {
            var lFoldMarkerInfo = myApp.Tools.getBoundsInfo(lFoldMarkers[0].geometricBounds);
            var lFold = lFoldMarkerInfo.midCenter.x - lFlap;
        }

        if( rFoldMarkers.length > 0) {
            var rFoldMarkerInfo = myApp.Tools.getBoundsInfo(rFoldMarkers[0].geometricBounds);
            var rFold = cpBounds.width-rFoldMarkerInfo.midCenter.x - rFlap;
        }

        var folds = rFold + lFold;
        if(folds > 0){
            NewC.fold = folds/2;
            NewC.inExCludeFold = 1; // Add to fold
        }

        // - - - - - - - - - - - - - - - - - - - - - -
        // C H E C K   F R O M   G U I D E S
        // - - - - - - - - - - - - - - - - - - - - - - 
        /*
        if( NewC.flap == 0 ) {
            // Front flaps
            // MBJ-Guide-FrontFlap-Inside
            // MBJ-Guide-FrontFlap-Outside-TurnaroundAffectsDocSize

        } */

        // Check the spine and front / back cover
        var lSpineMarkers = myApp.Tools.getItemByLabel(cpage, ["MBJ-FoldMark-SpineLeftBottom"  , "MBJ-FoldMark-SpineLeftTop"  , "MBJ-Guide-Spine-Left"]);
        var rSpineMarkers = myApp.Tools.getItemByLabel(cpage, ["MBJ-FoldMark-SpineRightBottom" , "MBJ-FoldMark-SpineRightTop" , "MBJ-Guide-Spine-Right"]);

        var cvr1CentreGuides = myApp.Tools.getItemByLabel(cpage, ["MBJ-Guide-FrontCover-Centering"]);
        var cvr4CentreGuides = myApp.Tools.getItemByLabel(cpage, ["MBJ-Guide-BackCover-Centering"]);

        // Maybe we should order these om x-value and get the middle one to remove any outlyers (users could have moved these)

        if( (lSpineMarkers.length > 0) && (rSpineMarkers.length > 0) ) {
            var lSpineMarkerInfo = myApp.Tools.getBoundsInfo(lSpineMarkers[0].geometricBounds);
            var rSpineMarkerInfo = myApp.Tools.getBoundsInfo(rSpineMarkers[0].geometricBounds);
            NewC.spine = rSpineMarkerInfo.midCenter.x - lSpineMarkerInfo.midCenter.x;
            NewC.width = (cpBounds.width-NewC.spine)/2;
            // Let's see if we can get a clearer picture of the width
            if( (cvr1CentreGuides.length > 0) && (cvr4CentreGuides.length > 0) ) {
                cvr1Centre = cvr1CentreGuides[0].location;
                cvr4Centre = cvr4CentreGuides[0].location;
                cvr1Width = myApp.NumCon.doRound( Math.abs(cvr1Centre - rSpineMarkerInfo.midCenter.x)*2, 4);
                cvr4Width = myApp.NumCon.doRound( Math.abs(lSpineMarkerInfo.midCenter.x - cvr4Centre)*2, 4);
                if( cvr1Width === cvr4Width || (NewC.spine === 0) ) { // Something is better then nothing :)
                    NewC.width = cvr1Width;
                    var leftOver = myApp.NumCon.doRound( cpBounds.width - ((NewC.flap*2)+(NewC.width*2)+NewC.spine) , 4);
                    if(NewC.fold > 0 && NewC.inExCludeFold == 1) {
                        leftOver -= (NewC.fold*2);
                    }
                    if(leftOver > 0) {
                        NewC.flap += leftOver/2;
                    }
                }
            }
        }

        return NewC;
    }

    function guessC( myApp, myDoc ) {
        // This function expects a valid document for param myDoc
        // It will return a valid C object
        // The function will try and construct a C object from a document not build with CoverBuilder
        // Or return a new empty C object

        var NewC = myApp.STools.newC(myApp);
            NewC.name = "Conclusion";

        // Check if one of the rulers is in a valid measure unit
        // Then set them both the same and safe the measuereunit
        var cUnit = myApp.NumCon.cUnit(myApp, myDoc.viewPreferences.horizontalMeasurementUnits) || myApp.NumCon.cUnit(myApp, myDoc.viewPreferences.verticalMeasurementUnits);
        if( cUnit == null ){
            cUnit = 0;
        }
        NewC.measureUnit = cUnit;

        // Safe current document rulers and set both rulers to a valid measure
        var oldRulers = myApp.Tools.setRuler(myDoc, {units : cUnit});

        // Check if it was build by other plugin
        var thirdParty = myApp.Tools.isBuildWithOther(myApp, myDoc);

        switch(thirdParty){
            case "Make Book Jacket":
                NewC = guessCfromMBJ(myApp, myDoc, NewC);
                break;
            default:
                NewC = guessCfromUnknown(myApp, myDoc, NewC);
                break;
        }

        var idealSlugSize = myApp.NumCon.convert(myApp, 5, "mm", NewC.measureUnit, 4);
        if(NewC.slugs < idealSlugSize ) NewC.slugs = idealSlugSize;

        // Reset original rulers
        myApp.Tools.setRuler(myDoc, oldRulers);

        return NewC;
    }

    //-----------------------------------------------------------------------------------
    //  PAGE TOOLS
    //-----------------------------------------------------------------------------------
    function insideMinMaxPageSize(myApp, size, measureUnit) {
        var minSize = myApp.Tools.getMinPageWidthINDD(myApp, measureUnit);
        var maxSize = myApp.Tools.getMaxPageWidthINDD(myApp, measureUnit);

        if( (size > minSize) && (size < maxSize) ) {
            return true;
        }

        return false;
    }

    function getCMarginFromPageLabel(myApp, C, pageLabel) {
        returnObj = { top : 0, right : 0, left : 0, bottom: 0 };

        var bindingHinge = 0;
        var cvr14Hinge = C.hinge;
        if(C.binding > C.hinge){
            cvr14Hinge = 0;
            bindingHinge = C.hinge;
        }

        switch (pageLabel) {
            case "CVRL":
                returnObj.top    = C.margin.CVR14.top;
                returnObj.right  = C.margin.CVR14.inside_left;
                returnObj.left   = C.margin.CVR14.outside_right;
                returnObj.bottom = C.margin.CVR14.bottom;
                if(cvr14Hinge > 0){
                    returnObj.right += myApp.NumCon.convert(myApp, C.hinge, C.measureUnit, C.margin.CVR14.units);
                }
                returnObj.units  = C.margin.CVR14.units;
                return returnObj;
                break;
            case "CVRR":
                returnObj.top    = C.margin.CVR14.top;
                returnObj.right  = C.margin.CVR14.outside_right;
                returnObj.left   = C.margin.CVR14.inside_left;
                returnObj.bottom = C.margin.CVR14.bottom;
                if(cvr14Hinge > 0){
                    returnObj.left += myApp.NumCon.convert(myApp, C.hinge, C.measureUnit, C.margin.CVR14.units);
                }
                returnObj.units  = C.margin.CVR14.units;
                return returnObj;
                break;
            case "Spine":
                returnObj.top    = C.margin.Spine.top;
                returnObj.right  = C.margin.Spine.outside_right;
                returnObj.left   = C.margin.Spine.inside_left;
                returnObj.bottom = C.margin.Spine.bottom;
                returnObj.units  = C.margin.Spine.units;
                return returnObj;
                break;
            case "FlapL":
                returnObj.top    = C.margin.Flaps.top;
                returnObj.right  = C.margin.Flaps.inside_left;
                returnObj.left   = C.margin.Flaps.outside_right;
                returnObj.bottom = C.margin.Flaps.bottom;
                // Add fold
                returnObj.right += myApp.NumCon.convert(myApp, C.fold, C.measureUnit, C.margin.Flaps.units);
                returnObj.units  = C.margin.Flaps.units;
                return returnObj;
                break;
            case "FlapR":
                returnObj.top    = C.margin.Flaps.top;
                returnObj.right  = C.margin.Flaps.outside_right;
                returnObj.left   = C.margin.Flaps.inside_left;
                returnObj.bottom = C.margin.Flaps.bottom;
                // Add fold
                returnObj.left  += myApp.NumCon.convert(myApp, C.fold, C.measureUnit, C.margin.Flaps.units);
                returnObj.units  = C.margin.Flaps.units;
                return returnObj;
                break;
            case "BindL":
                returnObj.top    = C.margin.QB.top;
                returnObj.right  = C.margin.QB.inside_left;
                returnObj.left   = C.margin.QB.outside_right;
                returnObj.bottom = C.margin.QB.bottom;
                if(bindingHinge > 0){
                    returnObj.right += myApp.NumCon.convert(myApp, C.hinge, C.measureUnit, C.margin.QB.units);
                }
                returnObj.units  = C.margin.QB.units;
                return returnObj;
                break;
            case "BindR":
                returnObj.top    = C.margin.QB.top;
                returnObj.right  = C.margin.QB.outside_right;
                returnObj.left   = C.margin.QB.inside_left;
                returnObj.bottom = C.margin.QB.bottom;
                if(bindingHinge > 0){
                    returnObj.left += myApp.NumCon.convert(myApp, C.hinge, C.measureUnit, C.margin.QB.units);
                }
                returnObj.units  = C.margin.QB.units;
                return returnObj;
                break;
            default:
                alert("Not a valid page label.");
                break;
        }
        return null;
    }

    function getPageMargins( myApp, page ){
        // BEWARE: This function assumes the document rulers are set correctly
        if(!page.isValid) {
            alert("Not a valid page: " + page);
            return null;
        }
        return {top     : myApp.NumCon.doRound( page.marginPreferences.top    , 3),
                right   : myApp.NumCon.doRound( page.marginPreferences.right  , 3),
                left    : myApp.NumCon.doRound( page.marginPreferences.left   , 3),
                bottom  : myApp.NumCon.doRound( page.marginPreferences.bottom , 3)};
    }

    function getPageMarginDifference(myApp, myPage, myMargins) {
        // returns margin object like this:
        // {top : 0, outside_right : 0, inside_left : 0, bottom : 0, units: myMargins.units}

        if(!myPage.isValid) {
            alert("Not a valid page: " + myPage);
            return null;
        }
        var oldRulers = myApp.Tools.setRuler(myPage.parent.parent, {units : myMargins.units});

        var pageMargin = myApp.Tools.getPageMargins(myApp, myPage);

        myApp.Tools.setRuler(myPage.parent.parent, oldRulers);

        var returnMargins = {   top     : pageMargin.top    - myApp.NumCon.doRound( myMargins.top    , 3),
                                right   : pageMargin.right  - myApp.NumCon.doRound( myMargins.right  , 3),
                                left    : pageMargin.left   - myApp.NumCon.doRound( myMargins.left   , 3),
                                bottom  : pageMargin.bottom - myApp.NumCon.doRound( myMargins.bottom , 3),
                                units   : myMargins.units };

        // allow margins of 0 (As coverbuilder sets the margin to zero when not fitting)
        if(pageMargin.top    == 0) returnMargins.top    = 0;
        if(pageMargin.right  == 0) returnMargins.right  = 0;
        if(pageMargin.left   == 0) returnMargins.left   = 0;
        if(pageMargin.bottom == 0) returnMargins.bottom = 0;

        return returnMargins;
    }

    function getGuides(myApp, myPageOrSpread){
        // This function returns all guides on the given spread
        // BEWARE: This function assumes the document rulers are set correctly
        var myGuides   = new Array();
        var guides     = myPageOrSpread.guides; // This does not include masterpage elements

        for (var g = 0; g < guides.length; g++) {
            var horizontal = false;
            if(String(guides[g].orientation) === "HORIZONTAL"){
                horizontal = true;
            }
            var boundsInfo = myApp.Tools.getBoundsInfo(guides[g].parentPage.bounds);
            myGuides.push({horizontal: horizontal, location: guides[g].location, label: String(guides[g].label), parentBounds: boundsInfo });
        }
        //alert("Horizontal: " + myGuides[0].horizontal + " location: " + myGuides[0].location + " label: " + myGuides[0].label);
        return myGuides;
    }

    function addVerticalCoverGuide(myApp, myPage, myLayer, myLocation, myLabel){
        var myLock = myApp.Tools.layerLocked(myLayer, false);
        var Guide  = myPage.guides.add({orientation:HorizontalOrVertical.vertical,location:myLocation, guideColor:UIColors.LIGHT_GRAY});
            Guide.label  = myLabel;
        myApp.Tools.layerLocked(myLayer, myLock);
    }

    function update_coverMaster_fold(myApp, doc, C) {
        var myMaster = doc.masterSpreads.item("CB-cover");

        var myLayer = getAndSelectLayer(doc, "Registration");
        var myLock  = layerLocked(myLayer, false);

        // Clear any old hinge folds
        myApp.Tools.clearItemsWithLabel(myApp, myMaster, "backFlapFoldGuide");
        myApp.Tools.clearItemsWithLabel(myApp, myMaster, "frontFlapFoldGuide");

        // Now run this function on every spread in document
        // In case some guides have overides
        for (var s = 0; s < doc.spreads.length; s++) {
            var mySpread = doc.spreads[s];
            // Clear any old hinge guides
            myApp.Tools.clearItemsWithLabel(myApp, mySpread, "backFlapFoldGuide");
            myApp.Tools.clearItemsWithLabel(myApp, mySpread, "frontFlapFoldGuide");
        }

        // Create new guides
        var flap4page = myApp.Tools.getMasterPage(myApp, doc, "CB-cover", "FlapL");
        var flap1page = myApp.Tools.getMasterPage(myApp, doc, "CB-cover", "FlapR");

        myApp.Tools.addVerticalCoverGuide(myApp, flap4page, myLayer, C.flap-C.fold, "backFlapFoldGuide" );
        myApp.Tools.addVerticalCoverGuide(myApp, flap1page, myLayer, C.fold,        "frontFlapFoldGuide");

        layerLocked(myLayer, myLock);
    }

    function update_coverMaster_hinge(myApp, doc, C) {

        // Keep in mind that the margins might need updating after this update

        var CR = myApp.STools.resolveSizes(myApp, C);

        var myMaster = doc.masterSpreads.item("CB-cover");

        var myLayer = getAndSelectLayer(doc, "Registration");
        var myLock  = layerLocked(myLayer, false);

        // Clear any old hinge guides
        myApp.Tools.clearItemsWithLabel(myApp, myMaster, "backHingeGuide");
        myApp.Tools.clearItemsWithLabel(myApp, myMaster, "frontHingeGuide");

        // Now run this function on every spread in document
        // In case some guides have overides
        for (var s = 0; s < doc.spreads.length; s++) {
            var mySpread = doc.spreads[s];
            // Clear any old hinge guides
            myApp.Tools.clearItemsWithLabel(myApp, mySpread, "backHingeGuide");
            myApp.Tools.clearItemsWithLabel(myApp, mySpread, "frontHingeGuide");
        }

        if(CR.hinge > 0){
            var leftPageName  = "CVRL";
            var rightPageName = "CVRR";
            var pageWidth     = CR.width;

            if(CR.binding  > 0){
                leftPageName  = "BindL";
                rightPageName = "BindR";
                pageWidth     = CR.binding;
            }

            var leftPage = myApp.Tools.getMasterPage(myApp, doc, "CB-cover", leftPageName  );
            var rightPage = myApp.Tools.getMasterPage(myApp, doc, "CB-cover", rightPageName );

            myApp.Tools.addVerticalCoverGuide(myApp, leftPage,  myLayer, pageWidth-CR.hinge, "backHingeGuide" );
            myApp.Tools.addVerticalCoverGuide(myApp, rightPage, myLayer, CR.hinge,           "frontHingeGuide");

        }

        layerLocked(myLayer, myLock);
    }

    function update_coverMaster_pageWidth(myApp, doc, C, pageLabel, pageWidth) {
        // Param pageWidth is in C.measureUnit
        var PageIO = myApp.Tools.makePageInfoObject(myApp, doc, myApp.Tools.getMasterPage(myApp, doc, "CB-cover", pageLabel), C.measureUnit);
        myApp.Tools.resizePage(myApp, doc, PageIO.page, [myApp.NumCon.convert(myApp, pageWidth, C.measureUnit, "pt"), myApp.NumCon.convert(myApp, C.height, C.measureUnit, "pt")]);
    }

    function update_coverMaster_pageHeight(myApp, doc, C){
        // This function resizes all pages to C.Height
        var myMasterSpread = doc.masterSpreads.item("CB-cover");
        if(!myMasterSpread.isValid){
            return "No master CB-cover found";
        }
        try{
            // Convert the height measurement to post script points
            var heightPoints = myApp.NumCon.convert(myApp, C.height, C.measureUnit, "pt");
            // Resize all pages in master-spread to this height
            for (var p = 0; p < myMasterSpread.pages.length; p++) {
                var infoPage = makePageInfoObject(myApp, doc, myMasterSpread.pages[p], 2);
                myApp.Tools.resizePage(myApp, doc, infoPage.page, [infoPage.w, heightPoints]);
                //infoPage.page.reframe(CoordinateSpaces.PAGE_COORDINATES, [[0,0],[infoPage.w, heightPoints]]);
            }
            myApp.Tools.yAlignPages(myMasterSpread);
        } catch(err){
            alert("CoverBuilder Error:\n" + e.message +  " (Line " + e.line + " in file " + e.fileName + ")");
            return err.description;
        }
        return "Done";
    }

    function update_coverMaster_margins(myApp, doc, C) {
        // This function assumes that measure units are set correctly
        var myMasterSpread = doc.masterSpreads.item("CB-cover");
        if(!myMasterSpread.isValid){
            return "No master CB-cover found";
        }

        var originalRulers = myApp.Tools.setRuler(doc, { units : 0 } );

        for (var p = 0; p < myMasterSpread.pages.length; p++) {
            var currPage = myMasterSpread.pages[p];
            var currLabel = currPage.label;
            var Cmargin = myApp.Tools.getCMarginFromPageLabel(myApp, C, currLabel);
            if (Cmargin == null) {
                alert("Could not update margins of cover master.");
                return;
            }

            myApp.Tools.setRuler(doc, { units : Cmargin.units } );

            var pageInfo = makePageInfoObject(myApp, doc, currPage, Cmargin.units);

            if(Cmargin.top + Cmargin.bottom < pageInfo.h) {
                currPage.marginPreferences.top    = Cmargin.top;
                currPage.marginPreferences.bottom = Cmargin.bottom;
            } else {
                currPage.marginPreferences.top    = 0;
                currPage.marginPreferences.bottom = 0;
            }

            if(Cmargin.right + Cmargin.left < pageInfo.w) {
                currPage.marginPreferences.right  = Cmargin.right;
                currPage.marginPreferences.left   = Cmargin.left;
            } else {
                currPage.marginPreferences.right  = 0;
                currPage.marginPreferences.left   = 0;
            }
        }

        myApp.Tools.setRuler(doc, originalRulers );
        return "Done";
    }

    function update_C_margins(myApp, doc, mySpread, C) {
        // Returns an updated clone of C.margin
        // Keep in mind that CoverBuilder does not handle different margins on the same type of page.
        // For example CVR1 will override the settings of CVR1 inside CVR14

        if(!mySpread.isValid){
            return "Expected a valid spread.";
        }

        // Clone standard margin Object (to be returned )
        try{
            var MarginObj = myApp.JSON.parse(myApp.JSON.stringify(C.margin));
        } catch (e) {
            alert("Error cloning margins.\n" + e.message +  " (Line " + e.line + " in file " + e.fileName + ")");
            return "Error cloning margins.";
        }

        // For simplicity sake I will set all margins in same units as C units
        var originalRulers = myApp.Tools.setRuler(doc, { units : C.measureUnit } );

        var bindingHinge = 0;
        var cvr14Hinge = C.hinge;
        if(C.binding > C.hinge){
            cvr14Hinge = 0;
            bindingHinge = C.hinge;
        }

        for (var p = 0; p < mySpread.pages.length; p++) {
            var currPage = mySpread.pages[p];
            var pageMargins = getPageMargins( myApp, currPage ); // {top, right, left, bottom} || null
            if(pageMargins == null) {
                continue;
            }
            var currLabel = currPage.label;

            switch (currLabel) {
                case "CVRL":
                    MarginObj.CVR14.top                = pageMargins.top    ;
                    MarginObj.CVR14.inside_left        = pageMargins.right  ;
                    MarginObj.CVR14.outside_right      = pageMargins.left   ;
                    MarginObj.CVR14.bottom             = pageMargins.bottom ;
                    if(cvr14Hinge > 0){
                        MarginObj.CVR14.inside_left += C.hinge; // No need to convert units as we are allready in the right units
                    }
                    MarginObj.CVR14.units              = C.measureUnit;
                    break;
                case "CVRR":
                    MarginObj.CVR14.top              = pageMargins.top    ;
                    MarginObj.CVR14.outside_right    = pageMargins.right  ;
                    MarginObj.CVR14.inside_left      = pageMargins.left   ;
                    MarginObj.CVR14.bottom           = pageMargins.bottom ;
                    if(cvr14Hinge > 0){
                        MarginObj.CVR14.inside_left += C.hinge; // No need to convert units as we are allready in the right units
                    }
                    MarginObj.CVR14.units           = C.measureUnit;
                    break;
                case "Spine":
                    MarginObj.Spine.top             = pageMargins.top    ;
                    MarginObj.Spine.outside_right   = pageMargins.right  ;
                    MarginObj.Spine.inside_left     = pageMargins.left   ;
                    MarginObj.Spine.bottom          = pageMargins.bottom ;
                    MarginObj.Spine.units           = C.measureUnit;
                    break;
                case "FlapL":
                    MarginObj.Flaps.top             = pageMargins.top    ;
                    MarginObj.Flaps.inside_left     = pageMargins.right  ;
                    MarginObj.Flaps.outside_right   = pageMargins.left   ;
                    MarginObj.Flaps.bottom          = pageMargins.bottom ;
                    // Add fold
                    MarginObj.Flaps.outside_right  += C.fold; // No need to convert units as we are allready in the right units
                    MarginObj.Flaps.units           = C.measureUnit;
                    break;
                case "FlapR":
                    MarginObj.Flaps.top             = pageMargins.top    ;
                    MarginObj.Flaps.outside_right   = pageMargins.right  ;
                    MarginObj.Flaps.inside_left     = pageMargins.left   ;
                    MarginObj.Flaps.bottom          = pageMargins.bottom ;
                    // Add fold
                    MarginObj.Flaps.inside_left    += C.fold; // No need to convert units as we are allready in the right units
                    MarginObj.Flaps.units           = C.measureUnit;
                    break;
                case "BindL":
                    MarginObj.QB.top            = pageMargins.top    ;
                    MarginObj.QB.inside_left    = pageMargins.right  ;
                    MarginObj.QB.outside_right  = pageMargins.left   ;
                    MarginObj.QB.bottom         = pageMargins.bottom ;
                    if(bindingHinge > 0){
                        MarginObj.QB.inside_left += C.hinge; // No need to convert units as we are allready in the right units
                    }
                    MarginObj.QB.units          = C.measureUnit;
                    break;
                case "BindR":
                    MarginObj.QB.top            = pageMargins.top    ;
                    MarginObj.QB.outside_right  = pageMargins.right  ;
                    MarginObj.QB.inside_left    = pageMargins.left   ;
                    MarginObj.QB.bottom         = pageMargins.bottom ;
                    if(bindingHinge > 0){
                        MarginObj.QB.inside_left += C.hinge; // No need to convert units as we are allready in the right units
                    }
                    MarginObj.QB.units          = C.measureUnit;
                    break;
                default:
                    alert("Not a valid page label.");
                    break;
            }
        } // End pages loop

        myApp.Tools.setRuler(doc, originalRulers);
        return MarginObj;
    }

    function resizePage(myApp, doc, myPage, myPointSize) {
        // param myPointSize: Width * Height in postscript points -> Array [int Width, int Height]

        // Make sure facing pages is on
        // so the pages will automatically stay connected
        var userFacingPages = doc.documentPreferences.facingPages;
        if(!userFacingPages) {
            doc.documentPreferences.facingPages = true;
        };

        // Make sure margins will fit, if margins don't fit set them to 0
        // set + safe original rulers
        var originalRulers = myApp.Tools.setRuler(doc, {units : "pt"});

        // [float Width, float Height]
        var marginMax = [myPage.marginPreferences.right + myPage.marginPreferences.left, myPage.marginPreferences.top + myPage.marginPreferences.bottom];

        if( marginMax[0] >= myPointSize[0] ) {
            myPage.marginPreferences.right = 0;
            myPage.marginPreferences.left = 0;
        };

        if( marginMax[0] >= myPointSize[1] ) {
            myPage.marginPreferences.top = 0;
            myPage.marginPreferences.bottom = 0;
        };

        // Check the column gutter
        if( myPage.marginPreferences.columnCount * myPage.marginPreferences.columnGutter >= myPointSize[0] ) {
            myPage.marginPreferences.columnGutter = 0;
        };
        // Only remove column count when it becomes a problem
        if( myPage.marginPreferences.columnCount > myPointSize[0] ) {
            myPage.marginPreferences.columnCount = 1; // minimum value
        };

        try{
            myPage.resize(CoordinateSpaces.INNER_COORDINATES,
                AnchorPoint.CENTER_ANCHOR,ResizeMethods.REPLACING_CURRENT_DIMENSIONS_WITH, myPointSize);
        } catch (e){
            alert("CoverBuilder Error:\n" + e.message +  " (Line " + e.line + " in file " + e.fileName + ")");
        };

        //set userPref back
        if(!userFacingPages) {
            // userFacingPages is always false if changed
            doc.documentPreferences.facingPages = userFacingPages;
        };

        myApp.Tools.setRuler(doc, originalRulers);
    };

    function yAlignPages(/*Spread*/spd,/*'top'|'center'|'bottom'*/vRef,/*uint=0*/refPageIndex,  pgs,a,t,i,yRef,dy)
    // This function is written by Marc Autret, thanks!
    // Source: https://forums.adobe.com/thread/2134539
    // -----------------------------------------------
    // spd           ::  any Spread or MasterSpread.
    // vRef          ::  the y-anchor ref relative to which pages are realigned (def:'center')
    // refPageIndex  ::  index (in spread) of a properly aligned page (def: 0.)
    {
        // Validate and reformat vRef.
        // ---
        vRef = vRef && /^top|bottom$/i.test(vRef) ?
            (vRef+'_').toUpperCase() :
            '';

        // Boring constants
        // ---
        const CS_PARENT = +CoordinateSpaces.parentCoordinates,
              ANY_ORIG  = [0,0],
              YTRANS_MX = [1,0,0,1,0,NaN],
              REF_ANCHOR = [
                +AnchorPoint[vRef+'CENTER_ANCHOR'],
                +BoundingBoxLimits.GEOMETRIC_PATH_BOUNDS,
                CS_PARENT
                ];

        pgs = spd.pages.everyItem().getElements();

        // Compute the Y-values relative to the spread (parent.)
        // ---
        for( i=pgs.length, a=[] ; i-- ; a[i]=pgs[i].resolve(REF_ANCHOR,CS_PARENT)[0][1] );

        // What is the Y to be used as a reference?
        // ---
        if( (i=a.length) > (refPageIndex>>>=0) ) refPageIndex = 0;
        yRef = a[refPageIndex];

        // Reposition mis-aligned pages.
        // ---
        while( i-- )
        {
            if( i==refPageIndex || yRef==a[i] ) continue;

            YTRANS_MX[5] = yRef - a[i]; // dy

            pgs[i].transform( CS_PARENT, ANY_ORIG, YTRANS_MX );
        }
    }

    function updateSpreadWithMaster( myApp, mySpread, myFullMasterName, force ) {
        var updatedPages = [];
        var force = Boolean(force);
        
        var doc = mySpread.parent;
        doc.documentPreferences.facingPages = true;

        for (var p = 0; p < mySpread.pages.length; p++) {
            var myPage = mySpread.pages[p];
            if(force) {
                updatedPages.push(myPage);
                myPage.appliedMaster = doc.masterSpreads.item(myFullMasterName);
            } else {
                var activeMaster = myPage.appliedMaster;
                if( activeMaster ) {
                    if(activeMaster.name == myFullMasterName){
                        updatedPages.push(myPage);
                        myPage.appliedMaster = doc.masterSpreads.item(myFullMasterName);
                    }
                }
            }
        }

        if( updatedPages.length > 0 ) {
            myApp.Tools.yAlignPages(mySpread);
        }

        doc.documentPreferences.facingPages = false;

        return updatedPages;
    }

    function updatePagesWithMaster(myApp, doc, myFullMasterName, force){
        for (var s = 0; s < doc.spreads.length; s++) {
            var mySpread = doc.spreads[s];
            myApp.Tools.updateSpreadWithMaster( myApp, mySpread, myFullMasterName, force );
        }
    }

    function updatePageCountSpread( spread, count ) {
        try {
            
            // Make sure facing pages is on
            // so the pages will automatically stay connected
            var doc = spread.parent;
            doc.documentPreferences.allowPageShuffle = false;
            doc.documentPreferences.facingPages = true;
            
            try {
                spread.allowPageShuffle = false;
            } catch ( isMaster ) { }
            
            var spreadCount = spread.pages.length;

            if(spreadCount > count) {
                // Remove excess pages
                var last = false;
                while ( spread.pages.length > count ) {
                    if( last ) {
                        spread.pages.lastItem().remove();
                    } else {
                        spread.pages.firstItem().remove();
                    }
                    last = !last;
                }
            } else if(spreadCount < count) {
                // Add more pages
                var last = false;
                while ( spread.pages.length < count ) {
                    if( last ) {
                        spread.pages.add(LocationOptions.AT_END);
                    } else {
                        spread.pages.add(LocationOptions.AT_BEGINNING);
                    }
                    last = !last;
                }
            }

            doc.documentPreferences.facingPages = false;

        } catch( err ) {
            alert( err );
        }
    }

    function updatePageCountAllSpreads( myApp, doc, count, includeMasters ) {
        if ( includeMasters ) {
            for(var s = 0; s < doc.masterSpreads.length; s++) {
                var spread = doc.masterSpreads[s];
                myApp.Tools.updatePageCountSpread( spread, count );
            }
        }
        for(var s = 0; s < doc.spreads.length; s++) {
            var spread = doc.spreads[s];
            myApp.Tools.updatePageCountSpread( spread, count );
        }
    }

    function getMinPageWidthINDD(myApp, myUnits, maxDecimals) {
        // maxDecimals is an optional parameter for rounding
        return myApp.NumCon.convert(myApp, myApp.Settings.minPageWidthINDD, "mm", myUnits, maxDecimals);
    }
    function getMaxPageWidthINDD(myApp, myUnits, maxDecimals) {
        // maxDecimals is an optional parameter for rounding
        return myApp.NumCon.convert(myApp, myApp.Settings.maxPageWidthINDD, "mm", myUnits, maxDecimals);
    }

    function pageTracker(myApp, C){
        var minimumPageWidth = myApp.Tools.getMinPageWidthINDD(myApp, C.measureUnit); // Minimum page width for indesign
        //page tracker
        var pt = {  L_cover    : { pp: 0, label: "CVRL" , master: "CB-WxH"   },
                    R_cover    : { pp: 2, label: "CVRR" , master: "CB-WxH"   },
                    spine      : { pp: 1, label: "Spine", master: "CB-spine" },
                    L_flapbind : { pp: 0, label: "FlapL", master: "CB-flap"  },
                    R_flapbind : { pp: 4, label: "FlapR", master: "CB-flap"  },
                    pageCount  : 3 };

        if(C.flap  > minimumPageWidth || C.binding  > minimumPageWidth){
            pt.pageCount  += 2;
            pt.L_cover.pp  = 1;
            pt.R_cover.pp  = 3;
            pt.spine.pp    = 2;

            if(C.binding  > minimumPageWidth){
                pt.L_cover.pp = 0;
                pt.R_cover.pp = 4;

                pt.L_flapbind.master = "CB-binding";
                pt.R_flapbind.master = "CB-binding";

                pt.L_flapbind.label = "BindL";
                pt.R_flapbind.label = "BindR";

                pt.L_flapbind.pp = 1;
                pt.R_flapbind.pp = 3;
            }
        }

        // If spine is 0, build front cover only
        if(C.spine == 0) {
            pt.pageCount  = 1;
            pt.R_cover.pp = 0;
            if(C.flap  > minimumPageWidth || C.binding  > minimumPageWidth){
                pt.pageCount    += 1;
                pt.R_flapbind.pp = 1;
                if(C.binding  > minimumPageWidth){
                    pt.R_flapbind.pp  = 0;
                    pt.R_cover.pp = 1;
                }

            }
        }

        return pt;
    }

    function makePageInfoObject(myApp, doc, myPage, myUnits){
        var infoPage       = new Object();
            infoPage.page  = myPage;
        return myApp.Tools.addPageInfo(myApp, doc, infoPage, myUnits);
    }

    function addPageInfo(myApp, doc, infoPage, myUnits){
        if (infoPage.page.isValid) {
            // set + safe original rulers
            var myOldRulers = myApp.Tools.setRuler(doc, {units : myUnits});
            var boundsInfo = myApp.Tools.getBoundsInfo(infoPage.page.bounds);
            infoPage.bounds = boundsInfo.bounds;
            infoPage.w = boundsInfo.width;
            infoPage.h = boundsInfo.height;
            // reset original rulers
            myApp.Tools.setRuler(doc, myOldRulers);
        } else {
            alert("Error 4378262:\n Info page does not contain a valid page.");
            return null;
        }
        return infoPage;
    }

    function getPageByLabel(pages, label){
        for (i=0;pages.length>i;i++){
            if(pages.item(i).label == label){
                return pages.item(i);
            }
        }
        return null;
    }

    function getMasterPage(myApp, doc, myName, myLabel){
        var myMasterSpread = doc.masterSpreads.item(myName);
        if(!myMasterSpread.isValid){
            alert("Error 4378262:\n Could not find master spread called: " + myName);
            return null;
        }

        var myMasterPage = getPageByLabel(myMasterSpread.pages, myLabel);

        if(myMasterPage == null) {
            alert("Error 4378263:\n Could not find master page labelled: " + myLabel + " on master spread: " + myName);
            return null;
        }

        return myMasterPage;
    }

    function getCVR1pageNo(C){
        if(C.flap > 0){
            return 4;
        } else if (C.binding > 0){
            return 5;
        } else {
            return 3;
        }
    }

    function getPageBleedBounds(myApp, doc, myPage, selector){
        var myCoverBleed = {
                Top    : doc.documentPreferences.documentBleedTopOffset,
                Bottom : doc.documentPreferences.documentBleedBottomOffset,
                Left   : doc.documentPreferences.documentBleedInsideOrLeftOffset,
                Right  : doc.documentPreferences.documentBleedOutsideOrRightOffset
            };

        var myBleedBounds = myPage.bounds; //[y1, x1, y2, x2]

        // Add top and bottom bleed
        myBleedBounds[0] -= myCoverBleed.Top;
        myBleedBounds[2] += myCoverBleed.Bottom;

        // Left and right bleed
        switch (selector){
            case 2:
                return myBleedBounds; // Return page-bounds with top+bottom bleed
                break;
            case 3:
                myBleedBounds[1] -= myCoverBleed.Left;
                return myBleedBounds;
                break;
            case 1:
                myBleedBounds[3] += myCoverBleed.Right;
                return myBleedBounds;
                break;
            default: // Return page-bounds without bleed
                return myPage.bounds;
                break;
        }
    }

    function getSpreadBounds(myApp, mySpread){
        // This functions returns the bounds of the spread in current measure units
        try{
            var firstPage = mySpread.pages[0];
            var lastPage  = mySpread.pages[mySpread.pages.length-1];
            var firstPageBounds = firstPage.bounds; //in the format [y1, x1, y2, x2], top-left and bottom-right
            var lastPageBounds  = lastPage.bounds;

            return [firstPageBounds[0],firstPageBounds[1],lastPageBounds[2],lastPageBounds[3]];
        } catch(e) {
            alert("CoverBuilder Error:\n" + e.message +  " (Line " + e.line + " in file " + e.fileName + ")");
            return null;
        }
    }

    function getPageMarginBounds(myApp, myPage){
        var pageBounds = myPage.bounds;

        var margin = myApp.Tools.getPageMargins( myApp, myPage );
        if( margin == null) {
            margin = { top     : 0,
                       right   : 0,
                       left    : 0,
                       bottom  : 0 };
        }

        return [ pageBounds[0] + margin.top, pageBounds[1] + margin.left, pageBounds[2] - margin.bottom, pageBounds[3] - margin.right ];
    }

    function getSpreadMarginBounds(myApp, mySpread){
        // This functions returns the bounds of the spread in current measure units
        try{
            var firstPage = mySpread.pages[0];
            var lastPage  = mySpread.pages[mySpread.pages.length-1];
            var firstPageMarginBounds   = myApp.Tools.getPageMarginBounds(myApp, firstPage);
            var lastPageMarginBounds    = myApp.Tools.getPageMarginBounds(myApp, lastPage);

            return [firstPageMarginBounds[0] , firstPageMarginBounds[1] , lastPageMarginBounds[2] , lastPageMarginBounds[3] ];
        } catch(e) {
            alert("CoverBuilder Error:\n" + e.message +  " (Line " + e.line + " in file " + e.fileName + ")");
            return null;
        }
    }

    function getSpreadSize(myApp, mySpread) {
        // This function returns the width and height of a spread
        var spreadSize = { width: 0, height: 0 };
        if(mySpread.isValid) {
            var spreadBounds  = getSpreadBounds(myApp, mySpread);
            spreadSize.height = Math.abs(spreadBounds[2] - spreadBounds[0]);
            spreadSize.width  = Math.abs(spreadBounds[3] - spreadBounds[1]);
        } else {
            alert("CoverBuilder getSpreadSize():\nExpected to receive a valid spread but received " + mySpread);
            return null;
        }
        return spreadSize;
    }

    function clearItemsWithLabel(myApp, myPageOrSpread, myLabel) {
        var pageItems = myApp.Tools.getItemByLabel(myPageOrSpread, myLabel);
        var len = pageItems.length;
        for (var i = len-1; i >= 0; i--){
            try {
                pageItems[i].remove();
            } catch(err) {
                alert("Could not clear item with label " + myLabel + "/n" + err);
            }
        }
    }

    function getItemByLabel(myPageOrSpread, labels, includeMasters){
        // This funcion returns an array of all items found with given label(s)
        // If nothing is found this function returns an empty array

        var inclMaster = Boolean( includeMasters );
        
        // So we can pass a single label too
        if (labels instanceof Array) {
            myLabels = labels;
        } else {
            myLabels = [labels];
        }

        var labelCount = myLabels.length;
        var allItems = new Array();

        function addToItems( foundElements ) {
            var len = foundElements.length;
            for (var i = len-1; i >= 0; i--){
                for (var l = labelCount-1; l >= 0; l--){
                    if(foundElements[i].label == myLabels[l]){
                        allItems.push(foundElements[i]);
                    }
                }
            }
        }

        if(myPageOrSpread.isValid){
            addToItems( myPageOrSpread.allPageItems );
            // Guides are not part of pageItems but they can have labels too!
            addToItems( myPageOrSpread.guides );

            if(inclMaster && myPageOrSpread.appliedMaster) {
                addToItems( myPageOrSpread.appliedMaster.allPageItems );
                addToItems( myPageOrSpread.appliedMaster.guides );
            }
        } else {
            alert("ERROR 759403253473: Expected a valid page or spread.");
        }

        return allItems;
    }

    //-----------------------------------------------------------------------------------
    // PAGE ITEMS TOOLS
    //-----------------------------------------------------------------------------------
    function getBoundsRelative2Page ( myApp, pageItem ) {
        // This function returns the geometric bounds relative
        // to parent page of given pageItem
        // ONLY HANDLES X VALUES FOR SPREAD! (IT IGNORES Y VALUES)

        if(pageItem.parentPage==null) return pageItem.visibleBounds;

        var lastX = 0;
        var parentSpread = pageItem.parentPage.parent;

        // switch to spread rulers per page
        var originalRulers = myApp.Tools.setRuler(parentSpread.parent, {origin: RulerOrigin.pageOrigin} );

        for (var p = 0; p < parentSpread.pages.length; p++) {
            if(parentSpread.pages[p] == pageItem.parentPage){
                break;
            }
            if(p > 0){ // don't include first
                lastX += parentSpread.pages[p].bounds[1];
            }
        }

        var ppBounds = pageItem.parentPage.bounds;
        var itBounds = pageItem.visibleBounds;

        // switch to spread rulers per spread
        myApp.Tools.setRuler(parentSpread.parent, {origin: RulerOrigin.spreadOrigin} );

        var it2Bounds = pageItem.visibleBounds;

        // reset original rulers
        myApp.Tools.setRuler(parentSpread.parent, originalRulers);

        if( (it2Bounds[1] - ppBounds[1]) < -0.001 ){
            // alert("Item sits over previous page");
            var relX1 = (itBounds[1] - ppBounds[1]) + lastX;
            var relX3 = (itBounds[3] - ppBounds[1]) + lastX;
        } else {
            // alert("Item sits on current page");
            var relX1 = itBounds[1];
            var relX3 = itBounds[3];
        }

        return [itBounds[0], relX1, itBounds[2], relX3];
    }

    function getBoundsRelative2Spread ( myApp, pageItem ) {
        // This function returns the geometric bounds relative
        // to parent spread of given pageItem
        // ONLY HANDLES X VALUES FOR SPREAD! (IT IGNORES Y VALUES)

        if(pageItem.parentPage==null) return pageItem.visibleBounds;

        var parentSpread = pageItem.parentPage.parent;

        // switch to spread rulers per page
        var originalRulers = myApp.Tools.setRuler(parentSpread.parent, {origin: RulerOrigin.spreadOrigin} );

        var itBounds = pageItem.visibleBounds;

        // reset original rulers
        myApp.Tools.setRuler(parentSpread.parent, originalRulers);

        return itBounds;
    }

    function getBoundsInfo(bounds){
        // This functions receives bounds (y1, x1, y2, x2)
        // and returns an object with bounds and info as below
        var topLeftY   = bounds[0];
        var topLeftX   = bounds[1];
        var botRightY  = bounds[2];
        var botRightX  = bounds[3];
        var height     = Math.abs(botRightY - topLeftY);
        var width      = Math.abs(botRightX - topLeftX);
        var halfWidth  = 0;
        var halfHeight = 0;
        if(width > 0) {
            halfWidth = width/2;
        }
        if(height > 0) {
            halfHeight = height/2;
        }

        return {    bounds    : bounds,
                    height    : height,
                    width     : width,
                    topLeft   : {x: topLeftX                , y: topLeftY               } ,
                    topCenter : {x: topLeftX + halfWidth    , y: topLeftY               } ,
                    topRight  : {x: botRightX               , y: topLeftY               } ,
                    midLeft   : {x: topLeftX                , y: topLeftY  + halfHeight } ,
                    midCenter : {x: topLeftX + halfWidth    , y: topLeftY  + halfHeight } ,
                    midRight  : {x: botRightX               , y: topLeftY  + halfHeight } ,
                    botLeft   : {x: topLeftX                , y: botRightY              } ,
                    botCenter : {x: topLeftX + halfWidth    , y: botRightY              } ,
                    botRight  : {x: botRightX               , y: botRightY              } };
    }

    function getBoundsOfset( myApp, itemBounds, relativeToBounds ) {
        // BEWARE: This function expects both bounds to be in the same
        //  X-Y coordinate space, and use the same measure unit!
        //
        //   X--------X--------X
        //   |  |   |   |      |
        //   |--X---X---X------|
        //   |  |   |   |      |
        //   |--X---X---X------|
        //   X  |   |   |      X
        //   |--X---X---X------|
        //   |  |   |   |      |
        //   |  |   |   |      |
        //   |  |   |   |      |
        //   X--------X--------X
        //
        // Fetch Bounds Info
        var relBounds  = myApp.Tools.getBoundsInfo(relativeToBounds);
        var itemBounds = myApp.Tools.getBoundsInfo(itemBounds);

        return { bounds    : itemBounds.bounds,
                 height    : itemBounds.height,
                 width     : itemBounds.width,
                 topLeft   : { x: itemBounds.topLeft.x   - relBounds.topLeft.x    , y: itemBounds.topLeft.y   - relBounds.topLeft.y    } ,
                 topCenter : { x: itemBounds.topCenter.x - relBounds.topCenter.x  , y: itemBounds.topCenter.y - relBounds.topCenter.y  } ,
                 topRight  : { x: itemBounds.topRight.x  - relBounds.topRight.x   , y: itemBounds.topRight.y  - relBounds.topRight.y   } ,
                 midLeft   : { x: itemBounds.midLeft.x   - relBounds.midLeft.x    , y: itemBounds.midLeft.y   - relBounds.midLeft.y    } ,
                 midCenter : { x: itemBounds.midCenter.x - relBounds.midCenter.x  , y: itemBounds.midCenter.y - relBounds.midCenter.y  } ,
                 midRight  : { x: itemBounds.midRight.x  - relBounds.midRight.x   , y: itemBounds.midRight.y  - relBounds.midRight.y   } ,
                 botLeft   : { x: itemBounds.botLeft.x   - relBounds.botLeft.x    , y: itemBounds.botLeft.y   - relBounds.botLeft.y    } ,
                 botCenter : { x: itemBounds.botCenter.x - relBounds.botCenter.x  , y: itemBounds.botCenter.y - relBounds.botCenter.y  } ,
                 botRight  : { x: itemBounds.botRight.x  - relBounds.botRight.x   , y: itemBounds.botRight.y  - relBounds.botRight.y   } };
    }

    function zeroBounds ( bounds ) {
        return [0, 0, bounds[2]-bounds[0], bounds[3]-bounds[1]];
    }

    function addTextFrame(myApp, myPage, myBounds, myString, myParagraphStyle, myRotationAngle, myLabel){
        var myTextFrame = myPage.textFrames.add();
        
        // Make sure [none] style is applied
        myTextFrame.applyObjectStyle( myPage.parent.parent.objectStyles[0], true, true );
        myTextFrame.strokeWeight = 0;
        myTextFrame.strokeColor = "None";
        myTextFrame.fillColor   = "None";

        app.activeWindow.transformReferencePoint = AnchorPoint.CENTER_ANCHOR;
        myTextFrame.rotationAngle = myRotationAngle;

        // Force indesign to stay on the right page before setting bounds
        // This is not the most elegant solution but at least it works consistently
        app.activeWindow.transformReferencePoint = AnchorPoint.BOTTOM_LEFT_ANCHOR;
        myTextFrame.move(myPage, [0.05, 0.05]); //Page cant be smaller than 0.5mm this number works in any measurement unit :)

        try {
            myTextFrame.geometricBounds = myBounds;
        } catch(error) {
            alert("Trouble setting bounding box to: " + myBounds + "\n" + error);
        }

        myTextFrame.contents = myString;
        myTextFrame.textFramePreferences.verticalJustification = VerticalJustification.CENTER_ALIGN;

        myTextFrame.label = myLabel;
        myTextFrame.paragraphs[0].appliedParagraphStyle = myParagraphStyle;
        return myTextFrame;
    }

    function addRectangle(myApp, myPage, myLayer, myBounds, myColour) {
        var rect = undefined;
        // myColour {fill:"None",stroke:"None"};
        try {
            // Create rectangle on layer
            var rect = myPage.rectangles.add(myLayer,{geometricBounds:myBounds, appliedObjectStyle: myPage.parent.parent.objectStyles.item(0), fillColor:myColour.fill, strokeColor:myColour.stroke});
        } catch(e){
            alert("Could not add new rectangle to page. (Error 5784930)\n" + e.message +  " (Line " + e.line + " in file " + e.fileName + ")");
        }
        return rect;
    }

    function newRect2Page(myApp, doc, myPage, myLayer, myUnits) {
        var rect = undefined;
        try{
            // Get page info
            var infoPage  = myApp.Tools.makePageInfoObject(myApp, doc, myPage, myUnits);
            // Place standard rectangle
            var rect = myApp.Tools.addRectangle(myApp, infoPage.page, myLayer, infoPage.bounds, {fill:"None",stroke:"None"});
        } catch (e){
            alert("Error 782345623450\n" + e.message +  " (Line " + e.line + " in file " + e.fileName + ")")
        }
        return rect;
    }

    function newRect2SpreadBleed(myApp, doc, mySpread, myLayer, myUnits) {
        var rect = myApp.Tools.newRect2Page(myApp, doc, mySpread.pages[0], myLayer, myUnits);
        myApp.Tools.pageitem_2_SpreadBleedBounds(myApp, doc, rect);
        return rect;
    }

    function pageitem_2_SpreadBleedBounds(myApp, doc, pageItem){
        var myPage    = pageItem.parentPage;
        var mySpread  = myPage.parent;

        if(!myPage.isValid){
            alert("CoverBuilder Error 8439020\nNot a valid page: " + myPage);
            return pageItem;
        }

        //check bounds
        // It does not matter what the measurement units are
        var rectBounds = pageItem.visibleBounds;

        var spreadBounds = myApp.Tools.getSpreadBounds(myApp, mySpread);

        if(spreadBounds == null){
            alert("CoverBuilder Error 8439021\nCould not get bounds of spread " + mySpread);
            return pageItem;
        }

        var pageWidth = spreadBounds[3]-spreadBounds[1];

        //check bleed (can be made more specific, good for now)
        var bleed = [doc.documentPreferences.documentBleedTopOffset,
                     doc.documentPreferences.documentBleedOutsideOrRightOffset,
                     doc.documentPreferences.documentBleedBottomOffset,
                     doc.documentPreferences.documentBleedInsideOrLeftOffset ];

        // [y1, x1, y2, x2]
        var bleedBound = new Array(spreadBounds[0]-bleed[0],spreadBounds[1]-bleed[3],spreadBounds[2]+bleed[2],spreadBounds[3]+bleed[1]);

        pageItem.visibleBounds = bleedBound;
        return pageItem;
    }

    //-----------------------------------------------------------------------------------
    //  LAYER TOOLS
    //-----------------------------------------------------------------------------------
    function getSelectAndMoveLayer(doc, name, afterlayerNo){
        return moveLayer(getAndSelectLayer(doc, name), afterlayerNo);
    }
    
    function getAndSelectLayer(doc, name) {
        return selectLayer(doc, getLayer(doc, name));
    }
    
    function getLayer(doc, name) {
        for (var i=0; i < doc.layers.length; i++) {
            if (doc.layers[i].name==name) return doc.layers[i];
        }
        return doc.layers.add({name:name});
    }
    
    function selectLayer(doc, layer){
        doc.activeLayer = layer;
        return layer;
    }
    
    function moveLayer(layer, afterlayerNo){
        try {
            layer.move(LocationOptions.AFTER,layer.parent.layers[afterlayerNo]);
            return layer
        } catch (e) {
            alert("CoverBuilder.Tools MoveLayer\n" + e.message +  " (Line " + e.line + " in file " + e.fileName + ")");
        }
    }

    function layerLocked(myLayer, givenLock){
        // givenLock: True:  Layer will be locked
        // givenLock: False: Layer will be unlocked
        originalLock = myLayer.locked;

        if(givenLock == undefined){
            // Toggle!
            var givenLock = !originalLock;
        }

        if(givenLock){
            myLayer.locked = true;
            return originalLock;
        } else {
            myLayer.locked = false;
            return originalLock;
        }
    }

    //-----------------------------------------------------------------------------------
    //  SELECTION TOOLS
    //-----------------------------------------------------------------------------------
    function itemsSelected(myApp, tellUser){
        // This function needs more work which can be done when needed.
        // Always return a Boolean
        var tellUser = tellUser || false;
        var selectionType = "something";
        if(app.selection.length < 1){
            if(tellUser){
                alert("Please select " + selectionType + " before running this function.");
            }
            return false;
        }
        return true;
    }

    //-----------------------------------------------------------------------------------
    //  COLOUR TOOLS
    //-----------------------------------------------------------------------------------
    //This awesome function found here: http://tomaxxi.com/2010/09/quicktip-add-custom-cmykrgbhex-colors-to-document/
    //Example: myColorAdd(myDoc, "My New Colour", ColorModel.PROCESS, [16,0,0,55]);
    function addColor(myDocument, myColorName, myColorModel, myColorValue, forceColor) {
        // The forceColor parameter makes existing swatch with the same name update to these new values
        if (myColorValue instanceof Array == false) {
            myColorValue = [(parseInt(myColorValue, 16) >> 16) & 0xff, (parseInt(myColorValue, 16) >> 8) & 0xff, parseInt(myColorValue, 16) & 0xff];
            myColorSpace = ColorSpace.RGB;
        } else {
            if (myColorValue.length == 3)
                myColorSpace = ColorSpace.RGB;
            else
                myColorSpace = ColorSpace.CMYK;
        }
        try {
            myColor = myDocument.colors.item(myColorName);
            myName = myColor.name;
        } catch (myError) {
            myColor = myDocument.colors.add();
            forceColor = true;
        }
        if(forceColor){
            myColor.properties = {
                name: myColorName,
                model: myColorModel,
                space: myColorSpace,
                colorValue: myColorValue
            };
        }
        return myColor;
    }

    function addCMYKswatch(myDocument, myColorName, myColorValue, forceColor) {
        // You can send RGB CMYK or HEX values
        // We convert the swatch after creation
        // to let InDesign handle the conversion

        var forceColor = forceColor || false; // Update swatch if nececairy
        var myColor = addColor(myDocument, String(myColorName), ColorModel.PROCESS, myColorValue, forceColor);

        myColor.space = ColorSpace.CMYK; // Magic!!

        if(myColorName === undefined) {
            myColor.name = "C=" + myColor.colorValue[0] + " M=" + myColor.colorValue[1] + " Y=" + myColor.colorValue[2] + " K=" + myColor.colorValue[3];
        }

        return myColor;
    }

    function getUIcolorValue( myUIcolor ) {
        if(myUIcolor.constructor === Array) {
            return pColour; // custom color
        } // else UIcolor
        switch( String(myUIcolor) ) {
            case "BLACK":
                return [0,0,0];
                break;
            case "BLUE":
                return [0,0,255];
                break;
            case "BRICK_RED":
                return [153,0,0];
                break;
            case "BROWN":
                return [153,51,0];
                break;
            case "BURGUNDY":
                return [153,0,51];
                break;
            case "CHARCOAL":
                return [170,163,181];
                break;
            case "CUTE_TEAL":
                return [130,206,193];
                break;
            case "CYAN":
                return [0,255,255];
                break;
            case "DARK_BLUE":
                return [0,0,135];
                break;
            case "DARK_GREEN":
                return [0,84,0];
                break;
            case "FIESTA":
                return [247,89,107];
                break;
            case "GOLD":
                return [255,153,0];
                break;
            case "GRASS_GREEN":
                return [153,204,0];
                break;
            case "GRAY":
                return [127,127,127];
                break;
            case "GREEN":
                return [79,255,79];
                break;
            case "GRID_BLUE":
                return [122,186,216];
                break;
            case "GRID_GREEN":
                return [156,221,155];
                break;
            case "GRID_ORANGE":
                return [255,181,107];
                break;
            case "LAVENDER":
                return [153,153,255];
                break;
            case "LIGHT_BLUE":
                return [79,153,255];
                break;
            case "LIGHT_GRAY":
                return [186,186,186];
                break;
            case "LIGHT_OLIVE":
                return [140,165,107];
                break;
            case "LIPSTICK":
                return [206,130,181];
                break;
            case "MAGENTA":
                return [255,79,255];
                break;
            case "OCHRE":
                return [153,102,0];
                break;
            case "OLIVE_GREEN":
                return [102,102,0];
                break;
            case "ORANGE":
                return [255,102,0];
                break;
            case "PEACH":
                return [255,153,153];
                break;
            case "PINK":
                return [255,153,204];
                break;
            case "PURPLE":
                return [102,0,102];
                break;
            case "RED":
                return [255,0,0];
                break;
            case "SULPHUR":
                return [206,206,130];
                break;
            case "TAN":
                return [204,153,102];
                break;
            case "TEAL":
                return [0,153,153];
                break;
            case "VIOLET":
                return [153,51,255];
                break;
            case "WHITE":
                return [255,255,255];
                break;
            case "YELLOW":
                return [255,255,79];
                break;
            default:
                alert("Could not find UI colour called " + String(pColor));
                return [185,185,185]; // LIGHT_GRAY
                break;
        }
    }

    function isLight(colour){
        // This function checks if the colour
        // is light (true) or dark (false)

        // Note that with light means close to white/pale!

        var isLight = false;
        var tint    = 100;

        if ( colour.hasOwnProperty('baseColor') ) {
            tint = colour.tintValue;
            var tempColour   = colour.baseColor.duplicate();
        } else {
            var tempColour   = colour.duplicate();
        }

        tempColour.space = ColorSpace.LAB;

        // HSB
        var hue        = tempColour.colorValue[0];
        var saturation = tempColour.colorValue[1];
        var brightness = tempColour.colorValue[2];

        // Check hue from 30 degrees orange to 210 degrees blue is the lighter side

        if( hue > 30 && hue < 210 ) {
            // Light side
            if(tint < 4) isLight = true;
            if( saturation < 15 && brightness > 90 ) {
                isLight = true;
            }
        } else {
            // Dark side
            if(tint < 2) isLight = true;
            if( saturation < 15 && brightness > 90 ) {
                isLight = true;
            }
        }

        tempColour.remove();
        return isLight;
    }

    //-----------------------------------------------------------------------------------
    //  UI TOOLS
    //-----------------------------------------------------------------------------------
    function inddUnits2Shorthand (indd_or_CoverBuilder_Units){
        switch (indd_or_CoverBuilder_Units) {
            case 0 : return 'mm';
            case 1 : return 'inch';
            case 2 : return 'pt';
            case 2051106676: return 'ag';
            case 2053336435: return 'cm';
            case 2053335395: return 'c';
            case 2053729891: return 'inches';
            case 2053729892: return 'inch';
            case 2053991795: return 'mm';
            case 2054187363: return 'p';
            case 2054188905: return 'pt';
            case 1514238068: return 'Apt';
            case 2051170665: return 'bai';
            case 1131639917: return 'cstm';
            case 1516790048: return 'ha';
            case 2051893612: return 'mils';
            case 2054187384: return 'px';
            case 2054255973: return 'q';
            case 2051691808: return 'u';
            default: return null;
        }
    }

    ////////////
    // expose //
    ////////////
    // Return an object exposed to the public
    return {
        // APPLICATION TOOLS
        setRuler                        : setRuler,
        setRedraw                       : setRedraw,
        isBuildWithOther                : isBuildWithOther,
        isBuildWithCoverBuilder         : isBuildWithCoverBuilder,
        // DOCUMENT TOOLS
        getShorthandDocUnits            : getShorthandDocUnits,
        getBookTitle                    : getBookTitle,
        getActiveCover                  : getActiveCover,
        getOrCreateActiveCover          : getOrCreateActiveCover,
        getDocBleed                     : getDocBleed,
        setDocBleed                     : setDocBleed,
        setMinSlugs                     : setMinSlugs,
        setSlugs                        : setSlugs,
        saveJSONLabel                   : saveJSONLabel,
        retrieveJSONLabel               : retrieveJSONLabel,
        getMaxSlug                      : getMaxSlug,
        getMinSlug                      : getMinSlug,
        getMaxBleed                     : getMaxBleed,
        guessC                          : guessC,
        guessCfromUnknown               : guessCfromUnknown,
        createBlueprint                 : createBlueprint,
        sameRulers                      : sameRulers,
        // PAGE TOOLS
        insideMinMaxPageSize            : insideMinMaxPageSize,
        getCMarginFromPageLabel         : getCMarginFromPageLabel,
        getPageMarginDifference         : getPageMarginDifference,
        getPageMargins                  : getPageMargins,
        getGuides                       : getGuides,
        addVerticalCoverGuide           : addVerticalCoverGuide,
        update_coverMaster_fold         : update_coverMaster_fold,
        update_coverMaster_hinge        : update_coverMaster_hinge,
        update_coverMaster_pageWidth    : update_coverMaster_pageWidth,
        update_coverMaster_pageHeight   : update_coverMaster_pageHeight,
        update_coverMaster_margins      : update_coverMaster_margins,
        update_C_margins                : update_C_margins,
        resizePage                      : resizePage,
        yAlignPages                     : yAlignPages,
        updateSpreadWithMaster          : updateSpreadWithMaster,
        updatePagesWithMaster           : updatePagesWithMaster,
        updatePageCountSpread           : updatePageCountSpread,
        updatePageCountAllSpreads       : updatePageCountAllSpreads,
        getMinPageWidthINDD             : getMinPageWidthINDD,
        getMaxPageWidthINDD             : getMaxPageWidthINDD,
        pageTracker                     : pageTracker,
        addPageInfo                     : addPageInfo,
        getMasterPage                   : getMasterPage,
        getPageByLabel                  : getPageByLabel,
        makePageInfoObject              : makePageInfoObject,
        getCVR1pageNo                   : getCVR1pageNo,
        getPageBleedBounds              : getPageBleedBounds,
        getSpreadBounds                 : getSpreadBounds,
        getPageMarginBounds             : getPageMarginBounds,
        getSpreadMarginBounds           : getSpreadMarginBounds,
        getSpreadSize                   : getSpreadSize,
        clearItemsWithLabel             : clearItemsWithLabel,
        getItemByLabel                  : getItemByLabel,
        // PAGE ITEMS TOOLS
        getBoundsRelative2Page          : getBoundsRelative2Page,
        getBoundsRelative2Spread        : getBoundsRelative2Spread,
        getBoundsInfo                   : getBoundsInfo,
        getBoundsOfset                  : getBoundsOfset,
        zeroBounds                      : zeroBounds,
        addTextFrame                    : addTextFrame,
        addRectangle                    : addRectangle,
        newRect2Page                    : newRect2Page,
        newRect2SpreadBleed             : newRect2SpreadBleed,
        pageitem_2_SpreadBleedBounds    : pageitem_2_SpreadBleedBounds,
        // LAYER TOOLS
        moveLayer                       : moveLayer,
        selectLayer                     : selectLayer,
        getLayer                        : getLayer,
        getAndSelectLayer               : getAndSelectLayer,
        getSelectAndMoveLayer           : getSelectAndMoveLayer,
        layerLocked                     : layerLocked,
        // SELECTION TOOLS
        itemsSelected                   : itemsSelected,
        // COLOUR TOOLS
        addColor                        : addColor,
        addCMYKswatch                   : addCMYKswatch,
        getUIcolorValue                 : getUIcolorValue,
        isLight                         : isLight,
        // UI TOOLS
        inddUnits2Shorthand             : inddUnits2Shorthand
    };
})();
