// CoverBuilderPS UI// Bruno Herfst 2014(function() {	//////////////	// privates //	//////////////	function buildDialog(myApp) {		var C = null; // The Cover Object this function will return		var presetChange = false;		var savePS    = myApp.STools.ButtonTXT.savePS;        var clearPS   = myApp.STools.ButtonTXT.clearPS;        var MarginObj = myApp.STools.MarginObj;		var MyPresets = myApp.STools.getPresets(myApp);		var f = myApp.STools.getFile(myApp.PathTo.preferences);		var uD = undefined,			vGrid = 55,			vGrid1 = 25,			fmargin = 17,			s = 10;		////// START BUILD DIALOG //////////////////////////////////////////////		var dlg = new Window('dialog', 'CoverBuilderPS v' + myApp.Settings.version);		dlg.alignChildren = "fill";		dlg.orientation = 'column';		dlg.spacing = s;		dlg.justify = "left";		//container for fill panels p		var pfill = dlg.add("group", uD, uD, {			borderStyle: 'none'		});		pfill.align = "fill";		pfill.alignChildren = "fill";		pfill.orientation = 'column';		///////////////////////////////////// PRESETS /////////////////////////////////////		var pS0 = pfill.add("panel", uD, "Presets");		pS0.margins = fmargin;		pS0.align = "right";		pS0.alignChildren = "right";		pS0.orientation = 'column';		var pS1 = pS0.add("group", uD, uD, {			borderStyle: 'none'		});		pS1.orientation = 'row';		pS0.align = "right";		pS1.alignChildren = "right";		dlg.presetDrop = pS1.add("dropdownlist", uD);		dlg.presetDrop.add('item', "-Custom-");		for (var i = 0, len = MyPresets.presets.length; i < len; i++) {			if (MyPresets.presets[i].name.length < 4) {				var mt = "\t\t\t(";			} else if (MyPresets.presets[i].name.length < 8) {				var mt = "\t\t(";			} else {				var mt = "\t("; //my tabs			}			dlg.presetDrop.add('item', MyPresets.presets[i].name + mt + MyPresets.presets[i].width + "×" + MyPresets.presets[i].height + ")");		};		dlg.presetDrop.items[0].selected = true;		dlg.presetDrop.minimumSize.width = (vGrid * 3 + s * 2) + vGrid1;		dlg.presetDrop.maximumSize.width = (vGrid * 3 + s * 2) + vGrid1; //copy to max for users creating essay names		pS1.saveBut = pS1.add("button", uD, savePS);		pS1.saveBut.minimumSize.width = vGrid * 2 + s;		var mid = []; //mm inch dropdown		mid[0] = "mm";		mid[1] = "inch";		dlg.measureDrop = pS1.add("dropdownlist", uD);		for (var i = 0, len = mid.length; i < len; i++) {			dlg.measureDrop.add('item', mid[i]);		};		dlg.measureDrop.items[0].selected = true;		dlg.measureDrop.minimumSize.width = vGrid + 5; //bug?		///////////////////////////////////// REQUIRED FIELDS /////////////////////////////////////		var rF0 = pfill.add("panel", uD, 'Required fields', {			borderStyle: 'black'		});		rF0.margins = fmargin;		rF0.align = "right";		rF0.alignChildren = "right";		rF0.orientation = 'column';		var rF1 = rF0.add("group", uD, uD, {			borderStyle: 'none'		});		rF1.orientation = "row";		//rF1.alignChildren="right";		dlg.widthLabel = rF1.add("statictext", uD, "Width:");		dlg.widthLabel.justify = "right";		dlg.widthLabel.minimumSize.width = vGrid;		dlg.widthInput = rF1.add("edittext", uD);		dlg.widthInput.characters = 6;		dlg.widthInput.minimumSize.width = vGrid;		dlg.heightLabel = rF1.add("statictext", uD, " Height:");		dlg.heightLabel.justify = "right";		dlg.heightLabel.minimumSize.width = vGrid;		dlg.heightInput = rF1.add("edittext", uD);		dlg.heightInput.characters = 6;		dlg.heightInput.minimumSize.width = vGrid;		dlg.ppiLabel = rF1.add("statictext", uD, " DPI:");		dlg.ppiLabel.justify = "right";		dlg.ppiLabel.minimumSize.width = vGrid;		dlg.ppiInput = rF1.add("edittext", uD);		dlg.ppiInput.characters = 6;		dlg.ppiInput.minimumSize.width = vGrid;		///////////////////////////////////// OPTIONAL SETTINGS /////////////////////////////////////		var oS0 = pfill.add("panel", uD, "Optional Settings");		oS0.margins = fmargin;		oS0.align = "right";		oS0.alignChildren = "right";		oS0.orientation = 'column';		oS3 = oS0.add("group", uD, uD, {			borderStyle: 'none'		});		oS3.orientation = 'row';		oS3.minimumSize.height = 25;		//margin but		var marginButAuto = ["Margins:Preset", "Margins:Custom", "Margins:None"]		dlg.marginBut = oS3.add("button", uD, marginButAuto[2]);		dlg.marginBut.minimumSize.width = (vGrid * 2 + s * 1) + vGrid1 - 1;		dlg.bleedLabel = oS3.add("statictext", uD, "Bleed:");		dlg.bleedLabel.justify = "right";		dlg.bleedLabel.minimumSize.width = vGrid;		dlg.bleedInput = oS3.add("edittext", uD);		dlg.bleedInput.characters = 6;		dlg.bleedInput.minimumSize.width = vGrid;		dlg.spineLabel = oS3.add("statictext", uD, " Spine:");		dlg.spineLabel.justify = "right";		dlg.spineLabel.minimumSize.width = vGrid;		dlg.spineInput = oS3.add("edittext", uD);		dlg.spineInput.characters = 6;		dlg.spineInput.minimumSize.width = vGrid;		oS2 = oS0.add("group", uD, uD, {			borderStyle: 'none'		});		oS2.orientation = 'row';		dlg.flapDrop = oS2.add("dropdownlist", uD);		dlg.flapDrop.add("item", "Flaps:");		dlg.flapDrop.add("item", "- Quarter Binding:");		dlg.flapDrop.add("item", "+ Quarter Binding:");		dlg.flapDrop.items[0].selected = true;		dlg.flapDrop.minimumSize.width = (vGrid * 2 + s * 1) + vGrid1;		dlg.flapInput = oS2.add("edittext", uD);		dlg.flapInput.characters = 6;		dlg.flapInput.minimumSize.width = vGrid;		dlg.inExCludeFoldDrop = oS2.add("dropdownlist", uD);		dlg.inExCludeFoldDrop.add("item", "- Fold:");		dlg.inExCludeFoldDrop.add("item", "+ Fold:");		dlg.inExCludeFoldDrop.items[1].selected = true;		dlg.inExCludeFoldDrop.minimumSize.width = vGrid * 2 + s * 1;		dlg.foldInput = oS2.add("edittext", uD);		dlg.foldInput.characters = 6;		dlg.foldInput.minimumSize.width = vGrid;		dlg.inExCludeFoldDrop.visible = false;		dlg.foldInput.visible = false;		oS1 = oS0.add("group", uD, uD, {			borderStyle: 'none'		});		oS1.orientation = 'row';		oS1.minimumSize.height = 25;		//oS1.align="left";		//oS1.alignChildren="left";		dlg.inExCludeHingeDrop = oS1.add("dropdownlist", uD);		dlg.inExCludeHingeDrop.add("item", "-Hinge:");		dlg.inExCludeHingeDrop.add("item", "+Hinge:");		dlg.inExCludeHingeDrop.items[0].selected = true;		dlg.inExCludeHingeDrop.minimumSize.width = (vGrid * 2 + s * 1) + vGrid1;		dlg.hingeInput = oS1.add("edittext", uD);		dlg.hingeInput.characters = 6;		dlg.hingeInput.minimumSize.width = vGrid;		//spacer but		dlg.spacerBut = oS1.add("button", uD, "");		dlg.spacerBut.minimumSize.width = (vGrid * 3 + s * 2) + 3;		dlg.spacerBut.visible = false;		///////////////////////////////////// BUTTONS /////////////////////////////////////		var b0 = pfill.add("group", uD, uD, {			borderStyle: 'none'		});		b0.margins = fmargin / 2;		b0.align = "center";		b0.alignChildren = "center";		b0.orientation = 'column';		var b1 = b0.add("group", uD, uD, {			borderStyle: 'none'		}); //button panel		b1.orientation = 'row';		b1.helpBut = b1.add("button", uD, "Help");		b1.helpBut.minimumSize.width = vGrid * 2 + s + vGrid1;		b1.cancelBut = b1.add("button", uD, "Cancel");		b1.cancelBut.minimumSize.width = vGrid * 2 + s + 5; //bug?		b1.buildBut = b1.add("button", uD, "OK");		b1.buildBut.minimumSize.width = vGrid * 2 + s;		// The funtionality		dlg.marginBut.onClick = function () {			showMarginWindow();		}		b1.cancelBut.onClick = function () {			dlg.close();		}		b1.helpBut.onClick = function () {			myApp.STools.visitURL("http://coverbuilder.brunoherfst.com/");		}		b1.buildBut.onClick = function () {			checkInput(myApp);		}		pS1.saveBut.onClick = function () {			if (pS1.saveBut.text == savePS) {				//create preset				var cp = add2Presets(prompt("Name:"));				if (cp != true) { //reset presets					alert("Error creating presets \nplease check input fields");				} else {					//update dialog					var i = MyPresets.presets.length - 1;					var mt, len = MyPresets.presets[i].name.length;					if (len < 4) { //my tabs						mt = "\t\t\t(";					} else if (len < 8) {						mt = "\t\t(";					} else {						mt = "\t(";					}					dlg.presetDrop.add('item', MyPresets.presets[i].name + mt + MyPresets.presets[i].width + "×" + MyPresets.presets[i].height + ")");					dlg.presetDrop.items[MyPresets.presets.length].selected = true; //no need to subtract 1 as array includes --save presets-- item at 0					try {						myApp.JSON.saveFile(myApp, MyPresets, f);					} catch (e) {						alert("Error saving presets \n" + e.description);					}				}			} else if (pS1.saveBut.text == clearPS) {				var index = parseInt(dlg.presetDrop.selection);				MyPresets.presets.splice(index - 1, 1);				dlg.presetDrop.remove(dlg.presetDrop.selection);				dlg.presetDrop.items[0].selected = true;				myApp.JSON.saveFile(myApp, MyPresets, f);			}		}		dlg.presetDrop.onChange = function () {			presetChange = true;			var x = parseInt(this.selection) - 1;			if (x == -1) {				pS1.saveBut.text = savePS;			} else {				//make sure user can’t delete last used settings				if (MyPresets.presets[x].name != "-Last Used-") {					pS1.saveBut.text = clearPS;				} else {					pS1.saveBut.text = savePS;				}				dlg.widthInput.text = MyPresets.presets[x].width;				dlg.heightInput.text = MyPresets.presets[x].height;				dlg.spineInput.text = MyPresets.presets[x].spine;				dlg.ppiInput.text = MyPresets.presets[x].ppi;				dlg.bleedInput.text = MyPresets.presets[x].bleed;				dlg.hingeInput.text = MyPresets.presets[x].hinge;				dlg.inExCludeHingeDrop.selection = MyPresets.presets[x].inExCludeHinge;				if (MyPresets.presets[x].binding > 0) {					dlg.flapInput.text = MyPresets.presets[x].binding;					if (MyPresets.presets[x].inExCludeQB == 0) {						dlg.flapDrop.selection = 1;					} else {						dlg.flapDrop.selection = 2;					}				} else { //set to flap					dlg.flapInput.text = MyPresets.presets[x].flap;					dlg.flapDrop.selection = 0;					if (MyPresets.presets[x].flap == 0) {						dlg.inExCludeFoldDrop.visible = false;						dlg.foldInput.visible = false;					} else {						dlg.inExCludeFoldDrop.visible = true;						dlg.foldInput.visible = true;					}				}				dlg.foldInput.text = MyPresets.presets[x].fold;				dlg.measureDrop.selection = MyPresets.presets[x].measureUnit;				dlg.inExCludeFoldDrop.selection = MyPresets.presets[x].inExCludeFold;				MarginObj = MyPresets.presets[x].margin;				dlg.marginBut.text = marginButAuto[0];			}			presetChange = false;		}		dlg.widthInput.onChange = function () {			this.text = NaN20(parseFloat(this.text.replace(",", ".")));			resetPresetDrop();		}		dlg.heightInput.onChange = function () {			this.text = NaN20(parseFloat(this.text.replace(",", ".")));			resetPresetDrop();		}		dlg.spineInput.onChange = function () {			this.text = NaN20(parseFloat(this.text.replace(",", ".")));			resetPresetDrop();		}		dlg.ppiInput.onChange = function () {			this.text = NaN20(parseFloat(this.text.replace(",", ".")));			resetPresetDrop();		}		dlg.bleedInput.onChange = function () {			this.text = NaN20(parseFloat(this.text.replace(",", ".")));			resetPresetDrop();		}		dlg.hingeInput.onChange = function () {			this.text = NaN20(parseFloat(this.text.replace(",", ".")));			resetPresetDrop();		}		dlg.inExCludeHingeDrop.onChange = function () {			resetPresetDrop();		}		dlg.flapDrop.onChange = function () {			resetPresetDrop();			if ((parseInt(this.selection) < 1) && (parseInt(dlg.flapInput.text) > 0)) {				//show fold				dlg.inExCludeFoldDrop.visible = true;				dlg.foldInput.visible = true;			} else {				//hide fold				dlg.inExCludeFoldDrop.visible = false;				dlg.foldInput.visible = false;			}		}		dlg.flapInput.onChange = function () {			this.text = NaN20(parseFloat(this.text.replace(",", ".")));			if (dlg.flapDrop.selection < 1 && (parseInt(this.text) > 0)) {				dlg.inExCludeFoldDrop.visible = true;				dlg.foldInput.visible = true;			} else {				dlg.inExCludeFoldDrop.visible = false;				dlg.foldInput.visible = false;			}			resetPresetDrop();		}		dlg.foldInput.onChange = function () {			this.text = NaN20(parseFloat(this.text.replace(",", ".")));			resetPresetDrop();		}		dlg.inExCludeFoldDrop.onChange = function () {			resetPresetDrop();		}		dlg.measureDrop.onChange = function () {			if (presetChange === false) {				//Save the selected value in a variable to be used later				dlg.smu = mid[parseInt(this.selection)]; //selected measurement units				//ask user if he wants to convert numbers				if (confirm("Do you want to convert numbers?") === true) {					convert2(dlg.smu);				}				resetPresetDrop();			}		}		function resetPresetDrop() {			if (presetChange === false) {				dlg.presetDrop.items[0].selected = true;			}		}		function NaN20(no) {			if (isNaN(no)) {				return 0;			} else {				return no;			}		}		function convert2(unit) {			var NC = myApp.NumCon;			switch (unit) {			case "mm":				dlg.widthInput.text  = NC.doRound(NC.inch2mm(Number(dlg.widthInput.text) ), 2);				dlg.heightInput.text = NC.doRound(NC.inch2mm(Number(dlg.heightInput.text)), 2);				dlg.spineInput.text  = NC.doRound(NC.inch2mm(Number(dlg.spineInput.text) ), 2);				dlg.bleedInput.text  = NC.doRound(NC.inch2mm(Number(dlg.bleedInput.text) ), 2);				dlg.hingeInput.text  = NC.doRound(NC.inch2mm(Number(dlg.hingeInput.text) ), 2);				dlg.flapInput.text   = NC.doRound(NC.inch2mm(Number(dlg.flapInput.text)  ), 2);				dlg.foldInput.text   = NC.doRound(NC.inch2mm(Number(dlg.foldInput.text)  ), 2);				break;			case "inch":				dlg.widthInput.text  = NC.doRound(NC.mm2inch(Number(dlg.widthInput.text) ), 3);				dlg.heightInput.text = NC.doRound(NC.mm2inch(Number(dlg.heightInput.text)), 3);				dlg.spineInput.text  = NC.doRound(NC.mm2inch(Number(dlg.spineInput.text) ), 3);				dlg.bleedInput.text  = NC.doRound(NC.mm2inch(Number(dlg.bleedInput.text) ), 3);				dlg.hingeInput.text  = NC.doRound(NC.mm2inch(Number(dlg.hingeInput.text) ), 3);				dlg.flapInput.text   = NC.doRound(NC.mm2inch(Number(dlg.flapInput.text)  ), 3);				dlg.foldInput.text   = NC.doRound(NC.mm2inch(Number(dlg.foldInput.text)  ), 3);				break;			default:				alert("Unable to convert values");			}		}		function add2Presets(newName) {			if (typeof newName == 'string') {				//check if newName is allready in list, if so remove the old one				var plen = MyPresets.presets.length - 1;				for (var i = plen; i >= 0; i--) {					if (MyPresets.presets[i].name == newName) {						//ask if the user wants to overwrite this preset						if (newName != "-Last Used-") {							var cool = confirm("There is allready a preset with that name.\nDo you want to overwrite it?");						} else {							var cool = true;						}						if (cool) {							//delete MyPresets.presets[i];							MyPresets.presets.splice(i, 1);							dlg.presetDrop.remove(i + 1); //add one for -presets-						} else {							return "error";						}					}				}				var newFlap, newFold, newQB, newInExQB = 0;;				if (dlg.flapDrop.selection == 0) {					newFlap = NaN20(parseFloat(dlg.flapInput.text));					newFold = NaN20(parseFloat(dlg.foldInput.text));					newQB = 0;				} else {					newFlap = 0;					newFold = 0;					newQB = NaN20(parseFloat(dlg.flapInput.text));					if (dlg.flapDrop.selection == 2) {						newInExQB++;					}				}				MyPresets.presets.push({					name: newName,					width: NaN20(parseFloat(dlg.widthInput.text)),					height: NaN20(parseFloat(dlg.heightInput.text)),					spine: NaN20(parseFloat(dlg.spineInput.text)),					ppi: NaN20(parseFloat(dlg.ppiInput.text)),					bleed: NaN20(parseFloat(dlg.bleedInput.text)),					hinge: NaN20(parseFloat(dlg.hingeInput.text)),					inExCludeHinge: NaN20(parseFloat(dlg.inExCludeHingeDrop.selection)),					binding: newQB,					inExCludeQB: newInExQB,					flap: newFlap,					fold: newFold,					inExCludeFold: NaN20(parseFloat(dlg.inExCludeFoldDrop.selection)),					margin: MarginObj,					measureUnit: NaN20(parseFloat(dlg.measureDrop.selection)),					publisher: "CoverBuilderPS",					finish: 1				});				return myApp.STools.sameProps(MyPresets,myApp.STools.PresetObj); //report back if it went well			} //end check for string			return "error";		}		function checkInput() {			var check;			// Let’s define a CoverObject			var C = new Object();			C.width  = Number(dlg.widthInput.text);			C.height = Number(dlg.heightInput.text);			C.spine  = Number(dlg.spineInput.text);			C.ppi    = Number(dlg.ppiInput.text);			C.bleed  = Number(dlg.bleedInput.text);			C.hinge  = Number(dlg.hingeInput.text);			C.inExCludeHinge = Number(dlg.inExCludeHingeDrop.selection);			if (Number(dlg.flapDrop.selection) > 0) {				C.inExCludeQB = 0;				if (Number(dlg.flapDrop.selection) == 2) {					C.inExCludeQB++;				}				C.binding = Number(dlg.flapInput.text);				C.flap    = 0;				C.fold    = 0;				if(C.binding < C.hinge){					alert("Quarter binding can’t be smaller than hinge.");					return;				}			} else {				C.binding = 0;				C.flap    = Number(dlg.flapInput.text);				C.fold    = Number(dlg.foldInput.text);				if(C.flap > 0 && C.spine == 0){					alert("You need to define the spine before setting Flaps");					return;				}			}			C.inExCludeFold = Number(dlg.inExCludeFoldDrop.selection);			C.margin        = MarginObj;			C.measureUnit   = Number(dlg.measureDrop.selection);			check = new Array(C.height, C.width, C.ppi);			for (var i = 0; i < check.length; i++) {				var thisValue = check[i];				if (thisValue == 0) {					alert("Width, Height or PPI can't be set to zero");					return;				}			}			check = new Array(C.width, C.height, C.spine, C.ppi, C.bleed, C.hinge, C.binding, C.flap, C.fold);			for (var i = 0; i < check.length; i++) {				var thisValue = check[i];				if (isNaN(thisValue)) {					alert("Not a Number\nEnter numbers only");					return;				}			}			///////////////////////////			// safe last used preset //			///////////////////////////			var cp = add2Presets("-Last Used-");			if (cp != true) { //reset presets				alert("Error saving presets \nSorry!");			} else {				try {					myApp.JSON.saveFile(myApp, MyPresets, f);				} catch (e) {					alert("Error saving presets \n" + e.description);				}			}			if (C.measureUnit == 1) { //convert inches to mm				C.height  *= 25.4;				C.width   *= 25.4;				C.spine   *= 25.4;				C.bleed   *= 25.4;				C.hinge   *= 25.4;				C.binding *= 25.4;				C.flap    *= 25.4;				C.fold    *= 25.4;			}			dlg.close();			//before we return the coverobject, lets add the object as string so we can safe it in the document			if(C != null){				C.JSONstring = myApp.JSON.stringify(C);			}			myApp.PSBuild.startBuilding(myApp, C);		}	//--------------------------------------------------------------------------------------------------- START MARGIN WINDOW	// This window should be shared with InDesign!!		function showMarginWindow() {			var marginWindow = new Window("dialog", "Set Margins");			marginWindow.orientation = "column";			var CoverGroup = marginWindow.add("Group");			CoverGroup.orientation = "row";			// create page panels			var pagePanels = new Array(),				pagePanelBool = new Object(),				CVR14Panel;			// Do not call this function twice, we safe only one setting for both the front and the back!			function insertCVR14(){				CVR14Panel = new panel(CoverGroup, "Front + Back Cover", MarginObj.CVR14);				pagePanels.push(CVR14Panel);				pagePanelBool.CVR14Panel = true;			}			// start creating the panels			// there is not always a spine			if (parseFloat(dlg.spineInput.text) > 0) {				// insert spine panel				var SpinePanel = new panel(CoverGroup, "Spine", MarginObj.Spine);				pagePanels.push(SpinePanel);				pagePanelBool.SpinePanel = true;				// check if there is a flap or quarter binding				if (parseFloat(dlg.flapInput.text) > 0) {					if (parseInt(dlg.flapDrop.selection) == 0) {						insertCVR14();						var FlapsPanel = new panel(CoverGroup, "Flap", MarginObj.Flaps);						pagePanels.push(FlapsPanel);						pagePanelBool.FlapsPanel = true;						pagePanelBool.QBPanel = false;					} else {						var QBPanel = new panel(CoverGroup, "Quarter Binding", MarginObj.QB);						pagePanels.push(QBPanel);						pagePanelBool.QBPanel = true;						pagePanelBool.FlapsPanel = false;						insertCVR14();					}				} else {					insertCVR14();				}			} else {				insertCVR14();			}			//update panels in class so they can interact			for (i = pagePanels.length - 1; i >= 0; i--) {				pagePanels[i].linkPanels(pagePanels);			}			// BUTTONS ///////////////////////////////////////////////			var myButtonGroup = marginWindow.add("group");			myButtonGroup.margins = [20, 5, 20, 15];			myButtonGroup.alignment = "center";			myButtonGroup.add("button", undefined, "Cancel");			myButtonGroup.add("button", undefined, "OK");			// BUTTONS ///////////////////////////////////////////////			var myResult = marginWindow.show();			if (myResult == true) {				// update main window				// it would be nice if to check if something has changed first				// if all values are zero button should change to "None"				// but I can't be bothered right now :)				dlg.marginBut.text = marginButAuto[1];				//update margin obj				if (pagePanelBool.CVR14Panel) {					MarginObj.CVR14 = CVR14Panel.getSettings();				}				if (pagePanelBool.SpinePanel) {					MarginObj.Spine = SpinePanel.getSettings();				}				if (pagePanelBool.QBPanel) {					MarginObj.QB = QBPanel.getSettings();				}				if (pagePanelBool.FlapsPanel) {					MarginObj.Flaps = FlapsPanel.getSettings();				}				return true;			} else {				return false;			}			function panel(thisGroup, panelName, theseMargins) {				this.changeInternal = false;				// panel class				this.name = panelName;				this.linkedPanels = new Array();				if (theseMargins.facing) {					this.inside_left_text = "inside";					this.outside_right_text = "outside";				} else {					this.inside_left_text = "left";					this.outside_right_text = "right";				}				this.Group = thisGroup.add('panel', undefined, this.name);				this.Group.margins = [15, 20, 15, 20];				this.Group.orientation = "row";				this.Group.alignment = "top";				// C O L U M N - 1				this.Row1 = this.Group.add("group");				this.Row1.orientation = "column";				this.Row1.alignment = "top";				this.Row1.add("statictext", undefined, " ");				this.Row1.add("statictext", undefined, " ");				//CVR1 Outside				this.Row1.add("statictext", undefined, this.inside_left_text);				this.inside_left = this.Row1.add("edittext", undefined, theseMargins.inside_left);				this.inside_left.characters = 6;				// C O L U M N - 2				this.Row2 = this.Group.add("group");				this.Row2.orientation = "column";				this.Row2.alignment = "top";				//CVR1 Top				this.Row2.add("statictext", undefined, "top");				this.top = this.Row2.add("edittext", undefined, theseMargins.top);				this.top.characters = 6;				this.Row2.add("statictext", undefined, " ");				//this.Row2.add ("statictext", undefined, " ");				this.unit = this.Row2.add("dropdownlist", undefined, ["mm", "inch", "pt"]);				this.unit.selection = theseMargins.units;				//CVR1 Bottom				this.Row2.add("statictext", undefined, "bottom");				this.bottom = this.Row2.add("edittext", undefined, theseMargins.bottom);				this.bottom.characters = 6;				this.Row2.add("statictext", undefined, " ");				this.link = this.Row2.add("checkbox", undefined, "Link");				this.link.value = theseMargins.linked;				this.drawGuides = this.Row2.add("checkbox", undefined, "Draw guides");				this.drawGuides.value = theseMargins.ps_guides;				// C O L U M N - 3				this.Row3 = this.Group.add("group");				this.Row3.orientation = "column";				this.Row3.alignment = "top";				this.Row3.add("statictext", undefined, " ");				this.Row3.add("statictext", undefined, " ");				//CVR1 Inside				this.Row3.add("statictext", undefined, this.outside_right_text);				this.outside_right = this.Row3.add("edittext", undefined, theseMargins.outside_right);				this.outside_right.characters = 6;				this.getSettings = function () {					return {						top: 			NaN20(parseFloat(this.top.text)),						outside_right:  NaN20(parseFloat(this.outside_right.text)),						inside_left: 	NaN20(parseFloat(this.inside_left.text)),						bottom: 		NaN20(parseFloat(this.bottom.text)),						facing: 		theseMargins.facing,						units: 			parseInt(this.unit.selection),						linked: 		this.link.value,						ps_guides:		this.drawGuides.value					}				}				this.linkPanels = function (panelArray) {					this.linkedPanels = panelArray;				}				this.upDate = function (ReplaceMargins) {					this.changeInternal = true; //prevent recursion					if (this.link.value) {						this.top.text = ReplaceMargins.top;						this.outside_right.text = ReplaceMargins.outside_right;						this.inside_left.text = ReplaceMargins.inside_left;						this.bottom.text = ReplaceMargins.bottom;						this.unit.selection = ReplaceMargins.units;					}					this.changeInternal = false;				}				var self = this;				self.changeLinked = function () {					if (self.link.value) {						var marginupdate = self.getSettings();						for (i = self.linkedPanels.length - 1; i >= 0; i--) {							if (self.name != self.linkedPanels[i].name) {								self.linkedPanels[i].upDate(marginupdate);							}						}					}				}				self.getLinkData = function () {					if (self.link.value) {						for (i = self.linkedPanels.length - 1; i >= 0; i--) {							if (self.name != self.linkedPanels[i].name) {								if (self.linkedPanels[i].link.value) {									self.upDate(self.linkedPanels[i].getSettings());									return;								}							}						}					}				}				self.link.onClick           = function () { self.getLinkData() };				self.unit.onChange          = function () { if (!self.changeInternal) { self.changeLinked() }};				self.inside_left.onChange   = function () { self.changeLinked() };				self.outside_right.onChange = function () { self.changeLinked() };				self.top.onChange           = function () { self.changeLinked() };				self.bottom.onChange        = function () { self.changeLinked() };			}			marginWindow.show();		}	//--------------------------------------------------------------------------------------------------- END MARGIN WINDOW		dlg.center();		dlg.show();	}	////////////	// expose //	////////////  	return {  		buildDialog : buildDialog	};})();