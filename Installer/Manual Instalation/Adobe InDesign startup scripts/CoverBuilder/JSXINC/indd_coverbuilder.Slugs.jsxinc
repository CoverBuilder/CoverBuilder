// CoverBuilder Slugs
// Bruno Herfst 2014

(function() {
	//////////////
	// privates //
	//////////////

	function doHeight(myApp, myCover, myParagraphStyle){
		var regLayer = myApp.Core.getAndSelectLayer(myCover, "Registration");
		//CVR1
		var mySpinePage = myCover.pages.middleItem();
		var myPage = myCover.pages.item(mySpinePage.index+1);
		var pageBounds = myPage.bounds;
		var myPageWidth = myApp.NumCon.doRound(pageBounds[3]-pageBounds[1], 2);
		var myPageHeight = myApp.NumCon.doRound(pageBounds[2]-pageBounds[0], 2);

		//right (Only do cover spread)
		var myPage  = myCover.masterSpreads[myCover.masterSpreads.length-1].pages.lastItem();
		var pageBounds = myPage.bounds;
		var myPageWidth = myApp.NumCon.doRound(pageBounds[3]-pageBounds[1], 2);
		var myPageHeight = myApp.NumCon.doRound(pageBounds[2]-pageBounds[0], 2);
		var myFrameBounds  = new Array (0,myPageWidth+myCover.documentPreferences.documentBleedOutsideOrRightOffset,myPageHeight,myPageWidth+myCover.documentPreferences.slugRightOrOutsideOffset);
		var tf1 = addTextFrame(myPage, myFrameBounds, myPageHeight.toString(), myParagraphStyle, 270, "pageHeight");

		//force a new frame to group, this makes sure items in slug of master spread will show up in doc
		var myPage = myCover.masterSpreads[myCover.masterSpreads.length-1].pages.firstItem();
		var myFrameBounds = new Array (0,-myCover.documentPreferences.slugRightOrOutsideOffset,myPageHeight,-myCover.documentPreferences.documentBleedOutsideOrRightOffset);
		var tf2 = addTextFrame(myPage, myFrameBounds, " ", myParagraphStyle, 270, "forcePageHeight");

		//group text frames
		var myGroup = [tf1,tf2];
			myGroup = myPage.groups.add(myGroup);
			myGroup.label = "forcePageHeightGroup";
	}
	function placeSizesInSlug(myApp, C, myCover){
		var myParagraphStyle = getMeasureParagraphStyle(myApp, myCover, "measurements");

		var regLayer = myApp.Core.getAndSelectLayer(myCover, "Registration");

		myCover.guides.everyItem().itemLayer = regLayer;

		//top
		for (i=0;myCover.masterSpreads.length-1>i;i++){
			for (j=0;myCover.masterSpreads[i].pages.length>j;j++){
				var myPage = myCover.masterSpreads[i].pages.item(j);
				var pageBounds = myPage.bounds;
				var myPageWidth = myApp.NumCon.doRound(pageBounds[3]-pageBounds[1], 2);
				var myFrameBounds = new Array (-myCover.documentPreferences.slugTopOffset,0,-myCover.documentPreferences.documentBleedTopOffset,myPageWidth);
				addTextFrame(myPage, myFrameBounds, myPageWidth.toString(), myParagraphStyle, 0,"pageWidth");
			}
		}

		doHeight(myApp, myCover, myParagraphStyle);

		//bottom
		if(C.finish){ // check if object excist
			var myFinish = "";
			switch (C.finish){
				case 1:
					myFinish = "Gloss Lamination";
					break;
				case 2:
					myFinish = "Matt Lamination";
					break;
				case 3:
					myFinish = "Silk Lamination";
					break;
				case 4:
					myFinish = "Satin Lamination";
					break;
				case 5:
					myFinish = "UV Varnish";
					break;
				case 6:
					myFinish = "Gloss Varnish";
					break;
				case 7:
					myFinish = "Matt Varnish";
					break;
				default:
					myFinish = "";
					break;
			}
			if(myFinish != ""){
				// we don’t want this on the masterpage
				var len = myCover.spreads[0].pages.length-1;
				if(C.flap  > 0.5){
					var myPage = myCover.spreads[0].pages[len-1];
				} else {
					var myPage = myCover.spreads[0].pages[len];
				}

				var pageBounds = myPage.bounds;
				var myPageWidth = myApp.NumCon.doRound(pageBounds[3]-pageBounds[1], 2);
				var myPageHeight = myApp.NumCon.doRound(pageBounds[2]-pageBounds[0], 2);
				var myFrameBounds = new Array (myPageHeight+myCover.documentPreferences.documentBleedBottomOffset,0,myPageHeight+myCover.documentPreferences.slugBottomOffset,myPageWidth);
				addTextFrame(myPage, myFrameBounds, "+ "+myFinish, myParagraphStyle, 0,"finish");
			}
		}
		myCover.layers[0].locked = true;
	}

	function getMeasureParagraphStyle(myApp, myCover, psName){
		var measureParagraphStyle = myCover.paragraphStyles.item(psName);
		if(!measureParagraphStyle.isValid) {
			// Create the measure style
			var measureParagraphStyle = myCover.paragraphStyles.add({name:psName});
			try{
				measureParagraphStyle.appliedFont = String(myApp.Settings.registration_font);
			} catch (e) {
				alert("Registration Font \n"+e.description);
				try{
					measureParagraphStyle.appliedFont = "Helvetica"; // try a standard one
				} catch (e) {
					//User already notified
				}
			}
			measureParagraphStyle.pointSize = "8pt";
			measureParagraphStyle.fillColor = "Registration";
			measureParagraphStyle.fillTint = 100;
			measureParagraphStyle.justification = 1667591796;
		}
		return measureParagraphStyle;
	}

	function addTextFrame(myPage, myBounds, myString, myParagraphStyle, myRotationAngle, myLabel){
		var myTextFrame = myPage.textFrames.add();
		app.activeWindow.transformReferencePoint = AnchorPoint.CENTER_ANCHOR;
		myTextFrame.rotationAngle = myRotationAngle;
		// force indesign to stay on the right page before setting bounds //
		// This is not the most elegant solution but at least it will always work even when InDesign changes it’s rules in the future
		app.activeWindow.transformReferencePoint = AnchorPoint.BOTTOM_LEFT_ANCHOR;
		myTextFrame.move(myPage, [0.4, 0.4]); //Page can’t be smaller than 0.5 :)
		myTextFrame.geometricBounds = [myBounds[0], myBounds[1], myBounds[2], myBounds[3]];

		myTextFrame.contents = myString;
		myTextFrame.textFramePreferences.verticalJustification = VerticalJustification.CENTER_ALIGN;

		myTextFrame.label = myLabel;
		myTextFrame.paragraphs[0].appliedParagraphStyle = myParagraphStyle;
		return myTextFrame;
	}

	function addPageInfo(myApp, myPage){
		myPage.bounds = myPage.page.bounds;
		myPage.w = myApp.NumCon.doRound(myPage.bounds[3]-myPage.bounds[1], 2);
		myPage.h = myApp.NumCon.doRound(myPage.bounds[2]-myPage.bounds[0], 2);
		return myPage;
	}

	function fetchPage(myApp, myCover, myName, myPage){
		var mPage = new Object(); //master spine
		mPage.name = myName;
		mPage.page = myCover.masterSpreads.item(mPage.name).pages[myPage];

		if(!mPage.page.isValid){
			alert("Can’t find the requested page!\nWhat happend to master spread "+mPage.name+"?");
			exit(); // I’m done here
		}

		mPage = addPageInfo(myApp, mPage);
		return mPage;
	}

	function fetchItem(myPage, myLabel){
		//returns first object that has itemlabel
		var myElements = myPage.parent.allPageItems;
		var len = myElements.length;
		for (var i = len-1; i >= 0; i--){
			if(myElements[i].label == myLabel){
				return myElements[i];
			}
		}
		return null;
	}

	function positionSlugWidth(C, myPage, myItem){
		myItem.geometricBounds = [-C.bleed-5, 0, -C.bleed, myPage.w];
		myItem.contents = myPage.w.toString();
	}

	function updateSpineSlug(myApp, myCover, C, newSpine){
		//ref to spinepage
		var mSpine = fetchPage(myApp, myCover, "CB-spine", 0);
		var myLayer = myCover.layers.itemByName("Registration");
		if(myLayer.isValid){
			//check if it is locked
			var myLock = myLayer.locked;
			if(myLock){
				//unlock
				myLayer.locked = false;
			}
			//update width
			var slugWidthFrame = fetchItem(mSpine.page, "pageWidth");
			if(slugWidthFrame != null){
				positionSlugWidth(C, mSpine, slugWidthFrame);
			}
			if(myLock){
				//lock
				myLayer.locked = true;
			}

			resetHeight(myApp,myCover);
		} else {
			alert("Could not find layer "+myLayerName);
			return false;
		}
	}

	function resetHeight(myApp,myCover){
		var CVR4 = fetchPage(myApp, myCover, "CB-cover", 0);
		var groupFix = fetchItem(CVR4.page, "forcePageHeightGroup");
		var myLayer = groupFix.itemLayer;
		if(myLayer.isValid){
			//check if it is locked
			var myLock = myLayer.locked;
			if(myLock){
				//unlock
				myLayer.locked = false;
			}
			var myParaS = getMeasureParagraphStyle(myApp, myCover, "measurements");
			groupFix.remove();
			doHeight(myApp, myCover, myParaS);
			if(myLock){
				//lock
				myLayer.locked = true;
			}
		}
	}
	////////////
	// expose //
	////////////
	return {
		fetchItem         : fetchItem,
		fetchPage         : fetchPage,
		updateSpineSlug   : updateSpineSlug,
		resetHeight       : resetHeight,
		placeSizesInSlug  : placeSizesInSlug
	};
})();
